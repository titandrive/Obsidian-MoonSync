/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/hardcover.ts
var hardcover_exports = {};
__export(hardcover_exports, {
  lookupBookBySlug: () => lookupBookBySlug,
  syncBooksToHardcover: () => syncBooksToHardcover,
  updateHardcoverBook: () => updateHardcoverBook,
  validateHardcoverToken: () => validateHardcoverToken
});
function escapeGraphQL(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}
function cleanTitleForSearch(title) {
  return title.replace(/-{2,}/g, " ").replace(/[^a-zA-Z0-9\s\u00C0-\u024F'-]/g, " ").replace(/\s+/g, " ").trim();
}
async function rateLimitDelay() {
  const now = Date.now();
  const elapsed = now - lastRequestTime;
  if (elapsed < 1100) {
    await new Promise((resolve) => setTimeout(resolve, 1100 - elapsed));
  }
  lastRequestTime = Date.now();
}
async function hardcoverGraphQL(query, token, variables) {
  const cleanToken = token.replace(/^Bearer\s+/i, "").replace(/\s/g, "");
  const payload = { query };
  if (variables) {
    payload.variables = variables;
  }
  const response = await (0, import_obsidian.requestUrl)({
    url: HARDCOVER_API,
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${cleanToken}`
    },
    body: JSON.stringify(payload)
  });
  const json = response.json;
  if (json.errors && json.errors.length > 0) {
    console.log("MoonSync: Hardcover GraphQL errors:", JSON.stringify(json.errors));
    throw new Error(json.errors[0].message);
  }
  return json;
}
async function validateHardcoverToken(token) {
  var _a, _b, _c;
  try {
    const result = await hardcoverGraphQL("query { me { username } }", token);
    return ((_c = (_b = (_a = result.data) == null ? void 0 : _a.me) == null ? void 0 : _b[0]) == null ? void 0 : _c.username) != null;
  } catch (error) {
    console.error("MoonSync: Hardcover validate failed", error);
    return false;
  }
}
async function lookupBookBySlug(slug, token) {
  var _a, _b, _c;
  try {
    await rateLimitDelay();
    const query = `{
			books(where: { slug: { _eq: "${escapeGraphQL(slug)}" } }, limit: 1) {
				id
				title
				slug
				pages
			}
		}`;
    const result = await hardcoverGraphQL(query, token);
    if (((_b = (_a = result.data) == null ? void 0 : _a.books) == null ? void 0 : _b.length) > 0) {
      const book = result.data.books[0];
      return { id: book.id, title: book.title, slug: book.slug, pages: (_c = book.pages) != null ? _c : null };
    }
  } catch (error) {
    console.debug("MoonSync: Hardcover slug lookup failed", error);
  }
  return null;
}
async function searchHardcoverBook(title, author, token, excludeId) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  try {
    await rateLimitDelay();
    const exactQuery = `{
			books(
				where: {
					contributions: { author: { name: { _eq: "${escapeGraphQL(author)}" } } },
					title: { _eq: "${escapeGraphQL(title)}" }
				},
				limit: 1,
				order_by: { users_read_count: desc }
			) {
				id
				title
				slug
				pages
			}
		}`;
    const result = await hardcoverGraphQL(exactQuery, token);
    if (((_b = (_a = result.data) == null ? void 0 : _a.books) == null ? void 0 : _b.length) > 0) {
      const book = result.data.books[0];
      if (!excludeId || book.id !== excludeId) {
        return { id: book.id, title: book.title, slug: book.slug, pages: (_c = book.pages) != null ? _c : null };
      }
    }
  } catch (error) {
    console.debug("MoonSync: Hardcover exact search failed", error);
  }
  try {
    await rateLimitDelay();
    const titleOnlyQuery = `{
			books(
				where: { title: { _eq: "${escapeGraphQL(title)}" } },
				limit: 1,
				order_by: { users_read_count: desc }
			) {
				id
				title
				slug
				pages
			}
		}`;
    const result = await hardcoverGraphQL(titleOnlyQuery, token);
    if (((_e = (_d = result.data) == null ? void 0 : _d.books) == null ? void 0 : _e.length) > 0) {
      const book = result.data.books[0];
      if (!excludeId || book.id !== excludeId) {
        return { id: book.id, title: book.title, slug: book.slug, pages: (_f = book.pages) != null ? _f : null };
      }
    }
  } catch (error) {
    console.debug("MoonSync: Hardcover title-only search failed", error);
  }
  const cleanTitle = cleanTitleForSearch(title);
  const searchQueries = [cleanTitle];
  const words = cleanTitle.split(" ");
  if (words.length > 3) {
    searchQueries.push(words.slice(0, Math.ceil(words.length / 2)).join(" "));
    const skipArticles = ["a", "an", "the"];
    const startIdx = skipArticles.includes(words[0].toLowerCase()) ? 1 : 0;
    const mainWord = words[startIdx] || words[0];
    if (!searchQueries.includes(mainWord)) {
      searchQueries.push(mainWord);
    }
  }
  for (const searchTitle of searchQueries) {
    try {
      await rateLimitDelay();
      const searchQuery = `{
				search(
					query: "${escapeGraphQL(searchTitle)}",
					query_type: "books",
					per_page: 5
				) {
					results
				}
			}`;
      const result = await hardcoverGraphQL(searchQuery, token);
      const hits = (_i = (_h = (_g = result.data) == null ? void 0 : _g.search) == null ? void 0 : _h.results) == null ? void 0 : _i.hits;
      if (hits && Array.isArray(hits) && hits.length > 0) {
        const bestHit = hits.reduce((best, h) => {
          var _a2;
          const bestCount = (best == null ? void 0 : best.users_count) || 0;
          const hCount = ((_a2 = h.document) == null ? void 0 : _a2.users_count) || 0;
          return hCount > bestCount ? h.document : best;
        }, hits[0].document);
        const doc = bestHit;
        const docId = (doc == null ? void 0 : doc.id) ? parseInt(String(doc.id), 10) : null;
        const docUsers = (doc == null ? void 0 : doc.users_count) || 0;
        console.log(`MoonSync: Hardcover search "${searchTitle}" \u2014 best hit: id=${docId}, users=${docUsers}, title="${doc == null ? void 0 : doc.title}"`);
        if (docId && (!excludeId || docId !== excludeId) && docUsers >= 10) {
          let pages = null;
          let slug = "";
          try {
            await rateLimitDelay();
            const detailQuery = `{ books(where: { id: { _eq: ${docId} } }, limit: 1) { slug pages } }`;
            const detailResult = await hardcoverGraphQL(detailQuery, token);
            const detail = (_k = (_j = detailResult.data) == null ? void 0 : _j.books) == null ? void 0 : _k[0];
            pages = (_l = detail == null ? void 0 : detail.pages) != null ? _l : null;
            slug = (_m = detail == null ? void 0 : detail.slug) != null ? _m : "";
          } catch (e) {
          }
          return { id: docId, title: doc.title || title, slug, pages };
        } else {
          console.log(`MoonSync: Hardcover search "${searchTitle}" \u2014 rejected (users=${docUsers}, need >= 10)`);
        }
      }
    } catch (error) {
      console.debug("MoonSync: Hardcover text search failed", error);
    }
  }
  return null;
}
async function updateHardcoverBook(bookId, statusId, progress, pages, token) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  try {
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    await rateLimitDelay();
    const meResult = await hardcoverGraphQL(FIND_USER_BOOK, token, { bookId });
    const meData = (_b = (_a = meResult.data) == null ? void 0 : _a.me) == null ? void 0 : _b[0];
    const privacySettingId = (_c = meData == null ? void 0 : meData.account_privacy_setting_id) != null ? _c : 1;
    let myUserBook = (_d = meData == null ? void 0 : meData.user_books) == null ? void 0 : _d[0];
    console.log(`MoonSync: Hardcover book ${bookId} \u2014 existing user_book:`, JSON.stringify(myUserBook));
    let progressIncreased = true;
    if (myUserBook) {
      const allReads = (_e = myUserBook.user_book_reads) != null ? _e : [];
      const unfinished = allReads.filter((r) => !r.finished_at);
      const lastRead = unfinished.length > 0 ? unfinished[unfinished.length - 1] : null;
      const existingPages = (_f = lastRead == null ? void 0 : lastRead.progress_pages) != null ? _f : 0;
      const edPages = (_h = (_g = myUserBook.edition) == null ? void 0 : _g.pages) != null ? _h : pages;
      const incomingPages = edPages && edPages > 0 ? Math.round(progress / 100 * edPages) : 0;
      progressIncreased = incomingPages > existingPages;
      console.log(`MoonSync: Hardcover book ${bookId} \u2014 existing progress: ${existingPages} pages, incoming: ${incomingPages} pages, increased: ${progressIncreased}`);
    }
    const needsStatusChange = !myUserBook || myUserBook.status_id !== statusId && progressIncreased;
    if (needsStatusChange) {
      await rateLimitDelay();
      const insertVars = {
        object: {
          book_id: bookId,
          status_id: statusId,
          privacy_setting_id: privacySettingId
        }
      };
      if (myUserBook == null ? void 0 : myUserBook.edition_id) {
        insertVars.object.edition_id = myUserBook.edition_id;
      }
      console.log(`MoonSync: Hardcover book ${bookId} \u2014 insert_user_book vars:`, JSON.stringify(insertVars));
      const statusResult = await hardcoverGraphQL(INSERT_USER_BOOK, token, insertVars);
      const insertResult = (_i = statusResult.data) == null ? void 0 : _i.insert_user_book;
      if (insertResult == null ? void 0 : insertResult.error) {
        console.log(`MoonSync: Hardcover insert_user_book error for book ${bookId}: ${insertResult.error}`);
      }
      console.log(`MoonSync: Hardcover insert_user_book response:`, JSON.stringify(insertResult == null ? void 0 : insertResult.user_book));
      if (insertResult == null ? void 0 : insertResult.user_book) {
        myUserBook = insertResult.user_book;
        if (!myUserBook.edition) {
          await rateLimitDelay();
          const reResult = await hardcoverGraphQL(FIND_USER_BOOK, token, { bookId });
          const freshUserBook = (_m = (_l = (_k = (_j = reResult.data) == null ? void 0 : _j.me) == null ? void 0 : _k[0]) == null ? void 0 : _l.user_books) == null ? void 0 : _m[0];
          if (freshUserBook) {
            myUserBook = freshUserBook;
          }
        }
      } else if (!myUserBook) {
        console.log(`MoonSync: Hardcover book ${bookId} \u2014 no user_book found after insert (bad edition)`);
        return { success: false, badEdition: true };
      }
    } else {
      console.log(`MoonSync: Hardcover book ${bookId} \u2014 status already ${statusId}, skipping insert_user_book`);
    }
    if (!myUserBook) {
      console.log(`MoonSync: Hardcover book ${bookId} \u2014 no user_book found (bad edition)`);
      return { success: false, badEdition: true };
    }
    return await updateProgressForBook(bookId, myUserBook, progress, pages, today, token);
  } catch (error) {
    console.log(`MoonSync: Hardcover update failed for book ${bookId}`, error);
    return { success: false, badEdition: false };
  }
}
async function updateProgressForBook(bookId, myUserBook, progress, pages, today, token) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  if (progress <= 0) {
    return { success: true, badEdition: false };
  }
  const editionId = (_c = (_b = (_a = myUserBook.edition) == null ? void 0 : _a.id) != null ? _b : myUserBook.edition_id) != null ? _c : null;
  const editionPages = (_e = (_d = myUserBook.edition) == null ? void 0 : _d.pages) != null ? _e : pages;
  console.log(`MoonSync: Hardcover book ${bookId} \u2014 editionId: ${editionId}, edition pages: ${(_f = myUserBook.edition) == null ? void 0 : _f.pages}, book pages: ${pages}, using: ${editionPages}, progress: ${progress}%`);
  if (!editionPages || editionPages <= 0) {
    console.log(`MoonSync: Hardcover book ${bookId} \u2014 no page count, skipping progress`);
    return { success: true, badEdition: false };
  }
  const progressPages = Math.round(progress / 100 * editionPages);
  const allReads = (_g = myUserBook.user_book_reads) != null ? _g : [];
  const unfinishedReads = allReads.filter((r) => !r.finished_at);
  const finishedReads = allReads.filter((r) => r.finished_at);
  console.log(`MoonSync: Hardcover book ${bookId} \u2014 ${allReads.length} total reads, ${unfinishedReads.length} unfinished, ${finishedReads.length} finished`);
  if (unfinishedReads.length > 1) {
    console.log(`MoonSync: Hardcover book ${bookId} \u2014 cleaning up ${unfinishedReads.length - 1} duplicate unfinished reads`);
    for (const dup of unfinishedReads.slice(0, -1)) {
      try {
        await rateLimitDelay();
        await hardcoverGraphQL(DELETE_USER_BOOK_READ, token, { id: dup.id });
        console.log(`MoonSync: Hardcover book ${bookId} \u2014 deleted duplicate read ${dup.id}`);
      } catch (err) {
        console.log(`MoonSync: Hardcover book ${bookId} \u2014 failed to delete read ${dup.id}:`, err);
      }
    }
  }
  const currentRead = unfinishedReads.length > 0 ? unfinishedReads[unfinishedReads.length - 1] : null;
  const existingReadId = (_h = currentRead == null ? void 0 : currentRead.id) != null ? _h : null;
  const existingStartedAt = (_i = currentRead == null ? void 0 : currentRead.started_at) != null ? _i : null;
  const existingEditionId = (_j = currentRead == null ? void 0 : currentRead.edition_id) != null ? _j : null;
  console.log(`MoonSync: Hardcover book ${bookId} \u2014 target: ${progressPages}/${editionPages} pages, currentRead: id=${existingReadId}, started=${existingStartedAt}, edition=${existingEditionId}`);
  if (existingReadId) {
    await rateLimitDelay();
    const vars = {
      id: existingReadId,
      pages: progressPages,
      editionId: editionId != null ? editionId : existingEditionId,
      startedAt: existingStartedAt != null ? existingStartedAt : today
    };
    console.log(`MoonSync: Hardcover update_user_book_read vars:`, JSON.stringify(vars));
    const updateResult = await hardcoverGraphQL(UPDATE_USER_BOOK_READ, token, vars);
    const updateData = (_k = updateResult.data) == null ? void 0 : _k.update_user_book_read;
    if (updateData == null ? void 0 : updateData.error) {
      console.log(`MoonSync: Hardcover update_user_book_read error for book ${bookId}: ${updateData.error}`);
    }
    console.log(`MoonSync: Hardcover update_user_book_read response:`, JSON.stringify(updateData == null ? void 0 : updateData.user_book_read));
  } else {
    const userBookId = myUserBook.id;
    await rateLimitDelay();
    const vars = {
      id: userBookId,
      pages: progressPages,
      editionId,
      startedAt: today
    };
    console.log(`MoonSync: Hardcover insert_user_book_read vars:`, JSON.stringify(vars));
    const insertResult = await hardcoverGraphQL(INSERT_USER_BOOK_READ, token, vars);
    const insertData = (_l = insertResult.data) == null ? void 0 : _l.insert_user_book_read;
    if (insertData == null ? void 0 : insertData.error) {
      console.log(`MoonSync: Hardcover insert_user_book_read error for book ${bookId}: ${insertData.error}`);
    }
    console.log(`MoonSync: Hardcover insert_user_book_read response:`, JSON.stringify(insertData == null ? void 0 : insertData.user_book_read));
  }
  return { success: true, badEdition: false };
}
async function syncBooksToHardcover(books, token, onProgress) {
  var _a, _b, _c, _d;
  const result = {
    booksUpdated: 0,
    booksFailed: 0,
    newIds: [],
    updatedTitles: [],
    notFoundTitles: [],
    slugs: /* @__PURE__ */ new Map()
  };
  const booksToSync = books.filter((b) => b.progress !== null);
  if (booksToSync.length === 0) {
    return result;
  }
  console.log(`MoonSync: Hardcover syncing ${booksToSync.length} books (of ${books.length} total)`);
  for (let i = 0; i < booksToSync.length; i++) {
    const book = booksToSync[i];
    console.log(`MoonSync: Hardcover [${i + 1}/${booksToSync.length}] "${book.title}" \u2014 progress: ${book.progress}%, hardcoverId: ${book.hardcoverId}`);
    onProgress == null ? void 0 : onProgress(`Hardcover: ${book.title} (${i + 1}/${booksToSync.length})`);
    try {
      let hardcoverId = book.hardcoverId;
      let pages = null;
      let slug = "";
      if (hardcoverId === null) {
        const match = await searchHardcoverBook(book.title, book.author, token);
        if (match) {
          hardcoverId = match.id;
          pages = match.pages;
          slug = match.slug;
          result.newIds.push({ title: book.title, author: book.author, hardcoverId, slug });
        } else {
          console.log(`MoonSync: Could not find "${book.title}" on Hardcover, skipping`);
          result.notFoundTitles.push(book.title);
          continue;
        }
      } else {
        try {
          await rateLimitDelay();
          const detailQuery = `{ books(where: { id: { _eq: ${hardcoverId} } }, limit: 1) { slug pages } }`;
          const detailResult = await hardcoverGraphQL(detailQuery, token);
          const detail = (_b = (_a = detailResult.data) == null ? void 0 : _a.books) == null ? void 0 : _b[0];
          pages = (_c = detail == null ? void 0 : detail.pages) != null ? _c : null;
          slug = (_d = detail == null ? void 0 : detail.slug) != null ? _d : "";
        } catch (e) {
        }
      }
      const p = book.progress;
      const statusId = p >= 99 ? STATUS_READ : p > 0 ? STATUS_CURRENTLY_READING : STATUS_WANT_TO_READ;
      let updated = await updateHardcoverBook(hardcoverId, statusId, p, pages, token);
      if (updated.badEdition) {
        console.log(`MoonSync: Bad edition ${hardcoverId} for "${book.title}", searching for alternative`);
        const match = await searchHardcoverBook(book.title, book.author, token, hardcoverId);
        if (match) {
          hardcoverId = match.id;
          pages = match.pages;
          slug = match.slug;
          result.newIds.push({ title: book.title, author: book.author, hardcoverId, slug });
          updated = await updateHardcoverBook(hardcoverId, statusId, p, pages, token);
        }
      }
      if (updated.success) {
        result.booksUpdated++;
        result.updatedTitles.push(book.title);
        if (slug)
          result.slugs.set(book.title, slug);
      } else {
        result.booksFailed++;
      }
    } catch (error) {
      result.booksFailed++;
      console.log(`MoonSync: Hardcover sync failed for "${book.title}"`, error);
    }
  }
  return result;
}
var import_obsidian, HARDCOVER_API, STATUS_WANT_TO_READ, STATUS_CURRENTLY_READING, STATUS_READ, lastRequestTime, USER_BOOK_PARTS, INSERT_USER_BOOK, UPDATE_USER_BOOK_READ, INSERT_USER_BOOK_READ, FIND_USER_BOOK, DELETE_USER_BOOK_READ;
var init_hardcover = __esm({
  "src/hardcover.ts"() {
    import_obsidian = require("obsidian");
    HARDCOVER_API = "https://api.hardcover.app/v1/graphql";
    STATUS_WANT_TO_READ = 1;
    STATUS_CURRENTLY_READING = 2;
    STATUS_READ = 3;
    lastRequestTime = 0;
    USER_BOOK_PARTS = `
	id
	book_id
	status_id
	edition_id
	rating
	user_book_reads(order_by: { id: asc }) {
		id
		started_at
		finished_at
		edition_id
		progress_pages
	}
`;
    INSERT_USER_BOOK = `
mutation InsertUserBook($object: UserBookCreateInput!) {
	insert_user_book(object: $object) {
		error
		user_book {
			${USER_BOOK_PARTS}
		}
	}
}`;
    UPDATE_USER_BOOK_READ = `
mutation UpdateBookProgress($id: Int!, $pages: Int, $editionId: Int, $startedAt: date) {
	update_user_book_read(id: $id, object: {
		progress_pages: $pages,
		edition_id: $editionId,
		started_at: $startedAt,
	}) {
		error
		user_book_read {
			id
			started_at
			finished_at
			edition_id
			progress_pages
			user_book {
				id
				book_id
				status_id
				edition_id
				rating
			}
		}
	}
}`;
    INSERT_USER_BOOK_READ = `
mutation InsertUserBookRead($id: Int!, $pages: Int, $editionId: Int, $startedAt: date) {
	insert_user_book_read(user_book_id: $id, user_book_read: {
		progress_pages: $pages,
		edition_id: $editionId,
		started_at: $startedAt,
	}) {
		error
		user_book_read {
			id
			started_at
			finished_at
			edition_id
			progress_pages
			user_book {
				id
				book_id
				status_id
				edition_id
				rating
			}
		}
	}
}`;
    FIND_USER_BOOK = `
query FindUserBook($bookId: Int!) {
	me {
		id
		account_privacy_setting_id
		user_books(where: { book_id: { _eq: $bookId } }) {
			id
			book_id
			status_id
			edition_id
			rating
			edition {
				id
				pages
			}
			user_book_reads(order_by: { id: asc }) {
				id
				started_at
				finished_at
				edition_id
				progress_pages
			}
		}
	}
}`;
    DELETE_USER_BOOK_READ = `
mutation DeleteRead($id: Int!) {
	delete_user_book_read(id: $id) {
		error
	}
}`;
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module2) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
      }
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof require && require;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof require && require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
            f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        "use strict";
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        "use strict";
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        "use strict";
        var n = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        "use strict";
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++)
            n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        "use strict";
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3)
                  throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        "use strict";
        function n() {
          if (!(this instanceof n))
            return new n();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this)
              "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n2 = 0; n2 < r2.length; n2++)
                t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        "use strict";
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files)
            n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t2.length; n2++)
              delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        "use strict";
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        "use strict";
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        "use strict";
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        "use strict";
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        "use strict";
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n2 = e3[t2++]) < 128)
                a2[r2++] = n2;
              else if (4 < (i2 = u[n2]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n2 = n2 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2)
              this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        "use strict";
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          "use strict";
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status)
            return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2)
            d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2)
            return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        "use strict";
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2)
                r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n2), i2);
          else
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
            n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++)
          u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++)
            r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n2++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        "use strict";
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
            return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
            if (2 === n2.wrap)
              e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n2.status)
            if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else
              n2.status = 73;
          if (73 === n2.status)
            if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else
              n2.status = 91;
          if (91 === n2.status)
            if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else
              n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out)
              return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
            return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in)
            return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
              return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
              return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
            return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
              ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if (0 == (64 & y)) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t2 || 6 === t2)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t2)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _ + 2; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z = _ + 3; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t2)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (0 === e2 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++)
            0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++)
            s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit)
            for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--)
                for (n3 = e3.bl_count[s3]; 0 !== n3; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
            i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
            if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                  ;
              else
                0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++)
              for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
              for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++)
              for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
                return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (0 !== e3.dyn_ltree[2 * t3])
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/sql.js/dist/sql-wasm.js
var require_sql_wasm = __commonJS({
  "node_modules/sql.js/dist/sql-wasm.js"(exports, module2) {
    var initSqlJsPromise = void 0;
    var initSqlJs3 = function(moduleConfig) {
      if (initSqlJsPromise) {
        return initSqlJsPromise;
      }
      initSqlJsPromise = new Promise(function(resolveModule, reject) {
        var Module = typeof moduleConfig !== "undefined" ? moduleConfig : {};
        var originalOnAbortFunction = Module["onAbort"];
        Module["onAbort"] = function(errorThatCausedAbort) {
          reject(new Error(errorThatCausedAbort));
          if (originalOnAbortFunction) {
            originalOnAbortFunction(errorThatCausedAbort);
          }
        };
        Module["postRun"] = Module["postRun"] || [];
        Module["postRun"].push(function() {
          resolveModule(Module);
        });
        module2 = void 0;
        var f;
        f || (f = typeof Module != "undefined" ? Module : {});
        var aa = "object" == typeof window, ba = "undefined" != typeof WorkerGlobalScope, ca = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node && "renderer" != process.type;
        "use strict";
        f.onRuntimeInitialized = function() {
          function a(g, l) {
            switch (typeof l) {
              case "boolean":
                dc(g, l ? 1 : 0);
                break;
              case "number":
                ec(g, l);
                break;
              case "string":
                fc(g, l, -1, -1);
                break;
              case "object":
                if (null === l)
                  lb(g);
                else if (null != l.length) {
                  var n = da(l, ea);
                  gc(g, n, l.length, -1);
                  fa(n);
                } else
                  va(g, "Wrong API use : tried to return a value of an unknown type (" + l + ").", -1);
                break;
              default:
                lb(g);
            }
          }
          function b(g, l) {
            for (var n = [], r = 0; r < g; r += 1) {
              var t = m(l + 4 * r, "i32"), y = hc(t);
              if (1 === y || 2 === y)
                t = ic(t);
              else if (3 === y)
                t = jc(t);
              else if (4 === y) {
                y = t;
                t = kc(y);
                y = lc(y);
                for (var L = new Uint8Array(t), J = 0; J < t; J += 1)
                  L[J] = p[y + J];
                t = L;
              } else
                t = null;
              n.push(t);
            }
            return n;
          }
          function c(g, l) {
            this.Qa = g;
            this.db = l;
            this.Oa = 1;
            this.lb = [];
          }
          function d(g, l) {
            this.db = l;
            l = ha(g) + 1;
            this.eb = ia(l);
            if (null === this.eb)
              throw Error("Unable to allocate memory for the SQL string");
            u(g, x, this.eb, l);
            this.kb = this.eb;
            this.Za = this.pb = null;
          }
          function e(g) {
            this.filename = "dbfile_" + (4294967295 * Math.random() >>> 0);
            if (null != g) {
              var l = this.filename, n = "/", r = l;
              n && (n = "string" == typeof n ? n : ja(n), r = l ? ka(n + "/" + l) : n);
              l = la(true, true);
              r = ma(r, l);
              if (g) {
                if ("string" == typeof g) {
                  n = Array(g.length);
                  for (var t = 0, y = g.length; t < y; ++t)
                    n[t] = g.charCodeAt(t);
                  g = n;
                }
                na(r, l | 146);
                n = oa(r, 577);
                pa(n, g, 0, g.length, 0);
                qa(n);
                na(r, l);
              }
            }
            this.handleError(q(this.filename, h));
            this.db = m(h, "i32");
            ob(this.db);
            this.fb = {};
            this.Sa = {};
          }
          var h = z(4), k = f.cwrap, q = k("sqlite3_open", "number", ["string", "number"]), w = k("sqlite3_close_v2", "number", ["number"]), v = k("sqlite3_exec", "number", ["number", "string", "number", "number", "number"]), C = k("sqlite3_changes", "number", ["number"]), G = k("sqlite3_prepare_v2", "number", ["number", "string", "number", "number", "number"]), pb = k("sqlite3_sql", "string", ["number"]), nc = k("sqlite3_normalized_sql", "string", ["number"]), qb = k("sqlite3_prepare_v2", "number", ["number", "number", "number", "number", "number"]), oc = k("sqlite3_bind_text", "number", ["number", "number", "number", "number", "number"]), rb = k("sqlite3_bind_blob", "number", ["number", "number", "number", "number", "number"]), pc = k("sqlite3_bind_double", "number", ["number", "number", "number"]), qc = k(
            "sqlite3_bind_int",
            "number",
            ["number", "number", "number"]
          ), rc = k("sqlite3_bind_parameter_index", "number", ["number", "string"]), sc = k("sqlite3_step", "number", ["number"]), tc = k("sqlite3_errmsg", "string", ["number"]), uc = k("sqlite3_column_count", "number", ["number"]), vc = k("sqlite3_data_count", "number", ["number"]), wc = k("sqlite3_column_double", "number", ["number", "number"]), sb = k("sqlite3_column_text", "string", ["number", "number"]), xc = k("sqlite3_column_blob", "number", ["number", "number"]), yc = k("sqlite3_column_bytes", "number", [
            "number",
            "number"
          ]), zc = k("sqlite3_column_type", "number", ["number", "number"]), Ac = k("sqlite3_column_name", "string", ["number", "number"]), Bc = k("sqlite3_reset", "number", ["number"]), Cc = k("sqlite3_clear_bindings", "number", ["number"]), Dc = k("sqlite3_finalize", "number", ["number"]), tb = k("sqlite3_create_function_v2", "number", "number string number number number number number number number".split(" ")), hc = k("sqlite3_value_type", "number", ["number"]), kc = k("sqlite3_value_bytes", "number", ["number"]), jc = k(
            "sqlite3_value_text",
            "string",
            ["number"]
          ), lc = k("sqlite3_value_blob", "number", ["number"]), ic = k("sqlite3_value_double", "number", ["number"]), ec = k("sqlite3_result_double", "", ["number", "number"]), lb = k("sqlite3_result_null", "", ["number"]), fc = k("sqlite3_result_text", "", ["number", "string", "number", "number"]), gc = k("sqlite3_result_blob", "", ["number", "number", "number", "number"]), dc = k("sqlite3_result_int", "", ["number", "number"]), va = k("sqlite3_result_error", "", ["number", "string", "number"]), ub = k(
            "sqlite3_aggregate_context",
            "number",
            ["number", "number"]
          ), ob = k("RegisterExtensionFunctions", "number", ["number"]), vb = k("sqlite3_update_hook", "number", ["number", "number", "number"]);
          c.prototype.bind = function(g) {
            if (!this.Qa)
              throw "Statement closed";
            this.reset();
            return Array.isArray(g) ? this.Cb(g) : null != g && "object" === typeof g ? this.Db(g) : true;
          };
          c.prototype.step = function() {
            if (!this.Qa)
              throw "Statement closed";
            this.Oa = 1;
            var g = sc(this.Qa);
            switch (g) {
              case 100:
                return true;
              case 101:
                return false;
              default:
                throw this.db.handleError(g);
            }
          };
          c.prototype.wb = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            return wc(this.Qa, g);
          };
          c.prototype.Gb = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            g = sb(this.Qa, g);
            if ("function" !== typeof BigInt)
              throw Error("BigInt is not supported");
            return BigInt(g);
          };
          c.prototype.Hb = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            return sb(this.Qa, g);
          };
          c.prototype.getBlob = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            var l = yc(this.Qa, g);
            g = xc(this.Qa, g);
            for (var n = new Uint8Array(l), r = 0; r < l; r += 1)
              n[r] = p[g + r];
            return n;
          };
          c.prototype.get = function(g, l) {
            l = l || {};
            null != g && this.bind(g) && this.step();
            g = [];
            for (var n = vc(this.Qa), r = 0; r < n; r += 1)
              switch (zc(this.Qa, r)) {
                case 1:
                  var t = l.useBigInt ? this.Gb(r) : this.wb(r);
                  g.push(t);
                  break;
                case 2:
                  g.push(this.wb(r));
                  break;
                case 3:
                  g.push(this.Hb(r));
                  break;
                case 4:
                  g.push(this.getBlob(r));
                  break;
                default:
                  g.push(null);
              }
            return g;
          };
          c.prototype.getColumnNames = function() {
            for (var g = [], l = uc(this.Qa), n = 0; n < l; n += 1)
              g.push(Ac(this.Qa, n));
            return g;
          };
          c.prototype.getAsObject = function(g, l) {
            g = this.get(g, l);
            l = this.getColumnNames();
            for (var n = {}, r = 0; r < l.length; r += 1)
              n[l[r]] = g[r];
            return n;
          };
          c.prototype.getSQL = function() {
            return pb(this.Qa);
          };
          c.prototype.getNormalizedSQL = function() {
            return nc(this.Qa);
          };
          c.prototype.run = function(g) {
            null != g && this.bind(g);
            this.step();
            return this.reset();
          };
          c.prototype.sb = function(g, l) {
            null == l && (l = this.Oa, this.Oa += 1);
            g = ra(g);
            var n = da(g, ea);
            this.lb.push(n);
            this.db.handleError(oc(this.Qa, l, n, g.length - 1, 0));
          };
          c.prototype.Bb = function(g, l) {
            null == l && (l = this.Oa, this.Oa += 1);
            var n = da(g, ea);
            this.lb.push(n);
            this.db.handleError(rb(
              this.Qa,
              l,
              n,
              g.length,
              0
            ));
          };
          c.prototype.rb = function(g, l) {
            null == l && (l = this.Oa, this.Oa += 1);
            this.db.handleError((g === (g | 0) ? qc : pc)(this.Qa, l, g));
          };
          c.prototype.Eb = function(g) {
            null == g && (g = this.Oa, this.Oa += 1);
            rb(this.Qa, g, 0, 0, 0);
          };
          c.prototype.tb = function(g, l) {
            null == l && (l = this.Oa, this.Oa += 1);
            switch (typeof g) {
              case "string":
                this.sb(g, l);
                return;
              case "number":
                this.rb(g, l);
                return;
              case "bigint":
                this.sb(g.toString(), l);
                return;
              case "boolean":
                this.rb(g + 0, l);
                return;
              case "object":
                if (null === g) {
                  this.Eb(l);
                  return;
                }
                if (null != g.length) {
                  this.Bb(
                    g,
                    l
                  );
                  return;
                }
            }
            throw "Wrong API use : tried to bind a value of an unknown type (" + g + ").";
          };
          c.prototype.Db = function(g) {
            var l = this;
            Object.keys(g).forEach(function(n) {
              var r = rc(l.Qa, n);
              0 !== r && l.tb(g[n], r);
            });
            return true;
          };
          c.prototype.Cb = function(g) {
            for (var l = 0; l < g.length; l += 1)
              this.tb(g[l], l + 1);
            return true;
          };
          c.prototype.reset = function() {
            this.freemem();
            return 0 === Cc(this.Qa) && 0 === Bc(this.Qa);
          };
          c.prototype.freemem = function() {
            for (var g; void 0 !== (g = this.lb.pop()); )
              fa(g);
          };
          c.prototype.free = function() {
            this.freemem();
            var g = 0 === Dc(this.Qa);
            delete this.db.fb[this.Qa];
            this.Qa = 0;
            return g;
          };
          d.prototype.next = function() {
            if (null === this.eb)
              return { done: true };
            null !== this.Za && (this.Za.free(), this.Za = null);
            if (!this.db.db)
              throw this.mb(), Error("Database closed");
            var g = sa(), l = z(4);
            ta(h);
            ta(l);
            try {
              this.db.handleError(qb(this.db.db, this.kb, -1, h, l));
              this.kb = m(l, "i32");
              var n = m(h, "i32");
              if (0 === n)
                return this.mb(), { done: true };
              this.Za = new c(n, this.db);
              this.db.fb[n] = this.Za;
              return { value: this.Za, done: false };
            } catch (r) {
              throw this.pb = ua(this.kb), this.mb(), r;
            } finally {
              wa(g);
            }
          };
          d.prototype.mb = function() {
            fa(this.eb);
            this.eb = null;
          };
          d.prototype.getRemainingSQL = function() {
            return null !== this.pb ? this.pb : ua(this.kb);
          };
          "function" === typeof Symbol && "symbol" === typeof Symbol.iterator && (d.prototype[Symbol.iterator] = function() {
            return this;
          });
          e.prototype.run = function(g, l) {
            if (!this.db)
              throw "Database closed";
            if (l) {
              g = this.prepare(g, l);
              try {
                g.step();
              } finally {
                g.free();
              }
            } else
              this.handleError(v(this.db, g, 0, 0, h));
            return this;
          };
          e.prototype.exec = function(g, l, n) {
            if (!this.db)
              throw "Database closed";
            var r = sa(), t = null;
            try {
              var y = xa(g), L = z(4);
              for (g = []; 0 !== m(y, "i8"); ) {
                ta(h);
                ta(L);
                this.handleError(qb(this.db, y, -1, h, L));
                var J = m(h, "i32");
                y = m(L, "i32");
                if (0 !== J) {
                  var I = null;
                  t = new c(J, this);
                  for (null != l && t.bind(l); t.step(); )
                    null === I && (I = { columns: t.getColumnNames(), values: [] }, g.push(I)), I.values.push(t.get(null, n));
                  t.free();
                }
              }
              return g;
            } catch (M) {
              throw t && t.free(), M;
            } finally {
              wa(r);
            }
          };
          e.prototype.each = function(g, l, n, r, t) {
            "function" === typeof l && (r = n, n = l, l = void 0);
            g = this.prepare(g, l);
            try {
              for (; g.step(); )
                n(g.getAsObject(
                  null,
                  t
                ));
            } finally {
              g.free();
            }
            if ("function" === typeof r)
              return r();
          };
          e.prototype.prepare = function(g, l) {
            ta(h);
            this.handleError(G(this.db, g, -1, h, 0));
            g = m(h, "i32");
            if (0 === g)
              throw "Nothing to prepare";
            var n = new c(g, this);
            null != l && n.bind(l);
            return this.fb[g] = n;
          };
          e.prototype.iterateStatements = function(g) {
            return new d(g, this);
          };
          e.prototype["export"] = function() {
            Object.values(this.fb).forEach(function(l) {
              l.free();
            });
            Object.values(this.Sa).forEach(A);
            this.Sa = {};
            this.handleError(w(this.db));
            var g = ya(this.filename);
            this.handleError(q(
              this.filename,
              h
            ));
            this.db = m(h, "i32");
            ob(this.db);
            return g;
          };
          e.prototype.close = function() {
            null !== this.db && (Object.values(this.fb).forEach(function(g) {
              g.free();
            }), Object.values(this.Sa).forEach(A), this.Sa = {}, this.Ya && (A(this.Ya), this.Ya = void 0), this.handleError(w(this.db)), za("/" + this.filename), this.db = null);
          };
          e.prototype.handleError = function(g) {
            if (0 === g)
              return null;
            g = tc(this.db);
            throw Error(g);
          };
          e.prototype.getRowsModified = function() {
            return C(this.db);
          };
          e.prototype.create_function = function(g, l) {
            Object.prototype.hasOwnProperty.call(
              this.Sa,
              g
            ) && (A(this.Sa[g]), delete this.Sa[g]);
            var n = Aa(function(r, t, y) {
              t = b(t, y);
              try {
                var L = l.apply(null, t);
              } catch (J) {
                va(r, J, -1);
                return;
              }
              a(r, L);
            }, "viii");
            this.Sa[g] = n;
            this.handleError(tb(this.db, g, l.length, 1, 0, n, 0, 0, 0));
            return this;
          };
          e.prototype.create_aggregate = function(g, l) {
            var n = l.init || function() {
              return null;
            }, r = l.finalize || function(I) {
              return I;
            }, t = l.step;
            if (!t)
              throw "An aggregate function must have a step function in " + g;
            var y = {};
            Object.hasOwnProperty.call(this.Sa, g) && (A(this.Sa[g]), delete this.Sa[g]);
            l = g + "__finalize";
            Object.hasOwnProperty.call(this.Sa, l) && (A(this.Sa[l]), delete this.Sa[l]);
            var L = Aa(function(I, M, Ra) {
              var X = ub(I, 1);
              Object.hasOwnProperty.call(y, X) || (y[X] = n());
              M = b(M, Ra);
              M = [y[X]].concat(M);
              try {
                y[X] = t.apply(null, M);
              } catch (Fc) {
                delete y[X], va(I, Fc, -1);
              }
            }, "viii"), J = Aa(function(I) {
              var M = ub(I, 1);
              try {
                var Ra = r(y[M]);
              } catch (X) {
                delete y[M];
                va(I, X, -1);
                return;
              }
              a(I, Ra);
              delete y[M];
            }, "vi");
            this.Sa[g] = L;
            this.Sa[l] = J;
            this.handleError(tb(this.db, g, t.length - 1, 1, 0, 0, L, J, 0));
            return this;
          };
          e.prototype.updateHook = function(g) {
            this.Ya && (vb(this.db, 0, 0), A(this.Ya), this.Ya = void 0);
            g && (this.Ya = Aa(function(l, n, r, t, y) {
              switch (n) {
                case 18:
                  l = "insert";
                  break;
                case 23:
                  l = "update";
                  break;
                case 9:
                  l = "delete";
                  break;
                default:
                  throw "unknown operationCode in updateHook callback: " + n;
              }
              r = r ? B(x, r) : "";
              t = t ? B(x, t) : "";
              if (y > Number.MAX_SAFE_INTEGER)
                throw "rowId too big to fit inside a Number";
              g(l, r, t, Number(y));
            }, "viiiij"), vb(this.db, this.Ya, 0));
          };
          f.Database = e;
        };
        var Ba = { ...f }, Ca = "./this.program", Da = (a, b) => {
          throw b;
        }, D = "", Ea, Fa;
        if (ca) {
          var fs = require("fs");
          require("path");
          D = __dirname + "/";
          Fa = (a) => {
            a = Ga(a) ? new URL(a) : a;
            return fs.readFileSync(a);
          };
          Ea = async (a) => {
            a = Ga(a) ? new URL(a) : a;
            return fs.readFileSync(a, void 0);
          };
          !f.thisProgram && 1 < process.argv.length && (Ca = process.argv[1].replace(/\\/g, "/"));
          process.argv.slice(2);
          "undefined" != typeof module2 && (module2.exports = f);
          Da = (a, b) => {
            process.exitCode = a;
            throw b;
          };
        } else if (aa || ba)
          ba ? D = self.location.href : "undefined" != typeof document && document.currentScript && (D = document.currentScript.src), D = D.startsWith("blob:") ? "" : D.slice(0, D.replace(/[?#].*/, "").lastIndexOf("/") + 1), ba && (Fa = (a) => {
            var b = new XMLHttpRequest();
            b.open("GET", a, false);
            b.responseType = "arraybuffer";
            b.send(null);
            return new Uint8Array(b.response);
          }), Ea = async (a) => {
            if (Ga(a))
              return new Promise((c, d) => {
                var e = new XMLHttpRequest();
                e.open("GET", a, true);
                e.responseType = "arraybuffer";
                e.onload = () => {
                  200 == e.status || 0 == e.status && e.response ? c(e.response) : d(e.status);
                };
                e.onerror = d;
                e.send(null);
              });
            var b = await fetch(a, { credentials: "same-origin" });
            if (b.ok)
              return b.arrayBuffer();
            throw Error(b.status + " : " + b.url);
          };
        var Ha = f.print || console.log.bind(console), Ia = f.printErr || console.error.bind(console);
        Object.assign(f, Ba);
        Ba = null;
        f.thisProgram && (Ca = f.thisProgram);
        var Ja = f.wasmBinary, Ka, La = false, Ma, p, x, Na, E, F, Oa, H, Pa, Ga = (a) => a.startsWith("file://");
        function Qa() {
          var a = Ka.buffer;
          f.HEAP8 = p = new Int8Array(a);
          f.HEAP16 = Na = new Int16Array(a);
          f.HEAPU8 = x = new Uint8Array(a);
          f.HEAPU16 = new Uint16Array(a);
          f.HEAP32 = E = new Int32Array(a);
          f.HEAPU32 = F = new Uint32Array(a);
          f.HEAPF32 = Oa = new Float32Array(a);
          f.HEAPF64 = Pa = new Float64Array(a);
          f.HEAP64 = H = new BigInt64Array(a);
          f.HEAPU64 = new BigUint64Array(a);
        }
        var K = 0, Sa = null;
        function Ta(a) {
          var _a;
          (_a = f.onAbort) == null ? void 0 : _a.call(f, a);
          a = "Aborted(" + a + ")";
          Ia(a);
          La = true;
          throw new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");
        }
        var Ua;
        async function Va(a) {
          if (!Ja)
            try {
              var b = await Ea(a);
              return new Uint8Array(b);
            } catch (e) {
            }
          if (a == Ua && Ja)
            a = new Uint8Array(Ja);
          else if (Fa)
            a = Fa(a);
          else
            throw "both async and sync fetching of the wasm failed";
          return a;
        }
        async function Wa(a, b) {
          try {
            var c = await Va(a);
            return await WebAssembly.instantiate(c, b);
          } catch (d) {
            Ia(`failed to asynchronously prepare wasm: ${d}`), Ta(d);
          }
        }
        async function Xa(a) {
          var b = Ua;
          if (!Ja && "function" == typeof WebAssembly.instantiateStreaming && !Ga(b) && !ca)
            try {
              var c = fetch(b, { credentials: "same-origin" });
              return await WebAssembly.instantiateStreaming(c, a);
            } catch (d) {
              Ia(`wasm streaming compile failed: ${d}`), Ia("falling back to ArrayBuffer instantiation");
            }
          return Wa(b, a);
        }
        class Ya {
          constructor(a) {
            __publicField(this, "name", "ExitStatus");
            this.message = `Program terminated with exit(${a})`;
            this.status = a;
          }
        }
        var Za = (a) => {
          for (; 0 < a.length; )
            a.shift()(f);
        }, $a = [], ab = [], bb = () => {
          var a = f.preRun.shift();
          ab.unshift(a);
        };
        function m(a, b = "i8") {
          b.endsWith("*") && (b = "*");
          switch (b) {
            case "i1":
              return p[a];
            case "i8":
              return p[a];
            case "i16":
              return Na[a >> 1];
            case "i32":
              return E[a >> 2];
            case "i64":
              return H[a >> 3];
            case "float":
              return Oa[a >> 2];
            case "double":
              return Pa[a >> 3];
            case "*":
              return F[a >> 2];
            default:
              Ta(`invalid type for getValue: ${b}`);
          }
        }
        var cb = f.noExitRuntime || true;
        function ta(a) {
          var b = "i32";
          b.endsWith("*") && (b = "*");
          switch (b) {
            case "i1":
              p[a] = 0;
              break;
            case "i8":
              p[a] = 0;
              break;
            case "i16":
              Na[a >> 1] = 0;
              break;
            case "i32":
              E[a >> 2] = 0;
              break;
            case "i64":
              H[a >> 3] = BigInt(0);
              break;
            case "float":
              Oa[a >> 2] = 0;
              break;
            case "double":
              Pa[a >> 3] = 0;
              break;
            case "*":
              F[a >> 2] = 0;
              break;
            default:
              Ta(`invalid type for setValue: ${b}`);
          }
        }
        var db = "undefined" != typeof TextDecoder ? new TextDecoder() : void 0, B = (a, b = 0, c = NaN) => {
          var d = b + c;
          for (c = b; a[c] && !(c >= d); )
            ++c;
          if (16 < c - b && a.buffer && db)
            return db.decode(a.subarray(b, c));
          for (d = ""; b < c; ) {
            var e = a[b++];
            if (e & 128) {
              var h = a[b++] & 63;
              if (192 == (e & 224))
                d += String.fromCharCode((e & 31) << 6 | h);
              else {
                var k = a[b++] & 63;
                e = 224 == (e & 240) ? (e & 15) << 12 | h << 6 | k : (e & 7) << 18 | h << 12 | k << 6 | a[b++] & 63;
                65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));
              }
            } else
              d += String.fromCharCode(e);
          }
          return d;
        }, ua = (a, b) => a ? B(x, a, b) : "", eb = (a, b) => {
          for (var c = 0, d = a.length - 1; 0 <= d; d--) {
            var e = a[d];
            "." === e ? a.splice(d, 1) : ".." === e ? (a.splice(d, 1), c++) : c && (a.splice(d, 1), c--);
          }
          if (b)
            for (; c; c--)
              a.unshift("..");
          return a;
        }, ka = (a) => {
          var b = "/" === a.charAt(0), c = "/" === a.slice(-1);
          (a = eb(a.split("/").filter((d) => !!d), !b).join("/")) || b || (a = ".");
          a && c && (a += "/");
          return (b ? "/" : "") + a;
        }, fb = (a) => {
          var b = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(a).slice(1);
          a = b[0];
          b = b[1];
          if (!a && !b)
            return ".";
          b && (b = b.slice(0, -1));
          return a + b;
        }, gb = (a) => a && a.match(/([^\/]+|\/)\/*$/)[1], hb = () => {
          if (ca) {
            var a = require("crypto");
            return (b) => a.randomFillSync(b);
          }
          return (b) => crypto.getRandomValues(b);
        }, ib = (a) => {
          (ib = hb())(a);
        }, jb = (...a) => {
          for (var b = "", c = false, d = a.length - 1; -1 <= d && !c; d--) {
            c = 0 <= d ? a[d] : "/";
            if ("string" != typeof c)
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!c)
              return "";
            b = c + "/" + b;
            c = "/" === c.charAt(0);
          }
          b = eb(b.split("/").filter((e) => !!e), !c).join("/");
          return (c ? "/" : "") + b || ".";
        }, kb = [], ha = (a) => {
          for (var b = 0, c = 0; c < a.length; ++c) {
            var d = a.charCodeAt(c);
            127 >= d ? b++ : 2047 >= d ? b += 2 : 55296 <= d && 57343 >= d ? (b += 4, ++c) : b += 3;
          }
          return b;
        }, u = (a, b, c, d) => {
          if (!(0 < d))
            return 0;
          var e = c;
          d = c + d - 1;
          for (var h = 0; h < a.length; ++h) {
            var k = a.charCodeAt(h);
            if (55296 <= k && 57343 >= k) {
              var q = a.charCodeAt(++h);
              k = 65536 + ((k & 1023) << 10) | q & 1023;
            }
            if (127 >= k) {
              if (c >= d)
                break;
              b[c++] = k;
            } else {
              if (2047 >= k) {
                if (c + 1 >= d)
                  break;
                b[c++] = 192 | k >> 6;
              } else {
                if (65535 >= k) {
                  if (c + 2 >= d)
                    break;
                  b[c++] = 224 | k >> 12;
                } else {
                  if (c + 3 >= d)
                    break;
                  b[c++] = 240 | k >> 18;
                  b[c++] = 128 | k >> 12 & 63;
                }
                b[c++] = 128 | k >> 6 & 63;
              }
              b[c++] = 128 | k & 63;
            }
          }
          b[c] = 0;
          return c - e;
        }, ra = (a, b) => {
          var c = Array(ha(a) + 1);
          a = u(a, c, 0, c.length);
          b && (c.length = a);
          return c;
        }, mb = [];
        function nb(a, b) {
          mb[a] = { input: [], output: [], cb: b };
          wb(a, xb);
        }
        var xb = { open(a) {
          var b = mb[a.node.rdev];
          if (!b)
            throw new N(43);
          a.tty = b;
          a.seekable = false;
        }, close(a) {
          a.tty.cb.fsync(a.tty);
        }, fsync(a) {
          a.tty.cb.fsync(a.tty);
        }, read(a, b, c, d) {
          if (!a.tty || !a.tty.cb.xb)
            throw new N(60);
          for (var e = 0, h = 0; h < d; h++) {
            try {
              var k = a.tty.cb.xb(a.tty);
            } catch (q) {
              throw new N(29);
            }
            if (void 0 === k && 0 === e)
              throw new N(6);
            if (null === k || void 0 === k)
              break;
            e++;
            b[c + h] = k;
          }
          e && (a.node.atime = Date.now());
          return e;
        }, write(a, b, c, d) {
          if (!a.tty || !a.tty.cb.qb)
            throw new N(60);
          try {
            for (var e = 0; e < d; e++)
              a.tty.cb.qb(a.tty, b[c + e]);
          } catch (h) {
            throw new N(29);
          }
          d && (a.node.mtime = a.node.ctime = Date.now());
          return e;
        } }, yb = { xb() {
          a: {
            if (!kb.length) {
              var a = null;
              if (ca) {
                var b = Buffer.alloc(256), c = 0, d = process.stdin.fd;
                try {
                  c = fs.readSync(d, b, 0, 256);
                } catch (e) {
                  if (e.toString().includes("EOF"))
                    c = 0;
                  else
                    throw e;
                }
                0 < c && (a = b.slice(0, c).toString("utf-8"));
              } else
                "undefined" != typeof window && "function" == typeof window.prompt && (a = window.prompt("Input: "), null !== a && (a += "\n"));
              if (!a) {
                a = null;
                break a;
              }
              kb = ra(a, true);
            }
            a = kb.shift();
          }
          return a;
        }, qb(a, b) {
          null === b || 10 === b ? (Ha(B(a.output)), a.output = []) : 0 != b && a.output.push(b);
        }, fsync(a) {
          var _a;
          0 < ((_a = a.output) == null ? void 0 : _a.length) && (Ha(B(a.output)), a.output = []);
        }, Tb() {
          return { Ob: 25856, Qb: 5, Nb: 191, Pb: 35387, Mb: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
        }, Ub() {
          return 0;
        }, Vb() {
          return [24, 80];
        } }, zb = { qb(a, b) {
          null === b || 10 === b ? (Ia(B(a.output)), a.output = []) : 0 != b && a.output.push(b);
        }, fsync(a) {
          var _a;
          0 < ((_a = a.output) == null ? void 0 : _a.length) && (Ia(B(a.output)), a.output = []);
        } }, O = { Wa: null, Xa() {
          return O.createNode(null, "/", 16895, 0);
        }, createNode(a, b, c, d) {
          if (24576 === (c & 61440) || 4096 === (c & 61440))
            throw new N(63);
          O.Wa || (O.Wa = { dir: { node: { Ta: O.La.Ta, Ua: O.La.Ua, lookup: O.La.lookup, hb: O.La.hb, rename: O.La.rename, unlink: O.La.unlink, rmdir: O.La.rmdir, readdir: O.La.readdir, symlink: O.La.symlink }, stream: { Va: O.Ma.Va } }, file: { node: { Ta: O.La.Ta, Ua: O.La.Ua }, stream: { Va: O.Ma.Va, read: O.Ma.read, write: O.Ma.write, ib: O.Ma.ib, jb: O.Ma.jb } }, link: { node: { Ta: O.La.Ta, Ua: O.La.Ua, readlink: O.La.readlink }, stream: {} }, ub: { node: { Ta: O.La.Ta, Ua: O.La.Ua }, stream: Ab } });
          c = Bb(a, b, c, d);
          P(c.mode) ? (c.La = O.Wa.dir.node, c.Ma = O.Wa.dir.stream, c.Na = {}) : 32768 === (c.mode & 61440) ? (c.La = O.Wa.file.node, c.Ma = O.Wa.file.stream, c.Ra = 0, c.Na = null) : 40960 === (c.mode & 61440) ? (c.La = O.Wa.link.node, c.Ma = O.Wa.link.stream) : 8192 === (c.mode & 61440) && (c.La = O.Wa.ub.node, c.Ma = O.Wa.ub.stream);
          c.atime = c.mtime = c.ctime = Date.now();
          a && (a.Na[b] = c, a.atime = a.mtime = a.ctime = c.atime);
          return c;
        }, Sb(a) {
          return a.Na ? a.Na.subarray ? a.Na.subarray(0, a.Ra) : new Uint8Array(a.Na) : new Uint8Array(0);
        }, La: { Ta(a) {
          var b = {};
          b.dev = 8192 === (a.mode & 61440) ? a.id : 1;
          b.ino = a.id;
          b.mode = a.mode;
          b.nlink = 1;
          b.uid = 0;
          b.gid = 0;
          b.rdev = a.rdev;
          P(a.mode) ? b.size = 4096 : 32768 === (a.mode & 61440) ? b.size = a.Ra : 40960 === (a.mode & 61440) ? b.size = a.link.length : b.size = 0;
          b.atime = new Date(a.atime);
          b.mtime = new Date(a.mtime);
          b.ctime = new Date(a.ctime);
          b.blksize = 4096;
          b.blocks = Math.ceil(b.size / b.blksize);
          return b;
        }, Ua(a, b) {
          for (var c of ["mode", "atime", "mtime", "ctime"])
            null != b[c] && (a[c] = b[c]);
          void 0 !== b.size && (b = b.size, a.Ra != b && (0 == b ? (a.Na = null, a.Ra = 0) : (c = a.Na, a.Na = new Uint8Array(b), c && a.Na.set(c.subarray(0, Math.min(b, a.Ra))), a.Ra = b)));
        }, lookup() {
          throw O.vb;
        }, hb(a, b, c, d) {
          return O.createNode(a, b, c, d);
        }, rename(a, b, c) {
          try {
            var d = Q(b, c);
          } catch (h) {
          }
          if (d) {
            if (P(a.mode))
              for (var e in d.Na)
                throw new N(55);
            Cb(d);
          }
          delete a.parent.Na[a.name];
          b.Na[c] = a;
          a.name = c;
          b.ctime = b.mtime = a.parent.ctime = a.parent.mtime = Date.now();
        }, unlink(a, b) {
          delete a.Na[b];
          a.ctime = a.mtime = Date.now();
        }, rmdir(a, b) {
          var c = Q(a, b), d;
          for (d in c.Na)
            throw new N(55);
          delete a.Na[b];
          a.ctime = a.mtime = Date.now();
        }, readdir(a) {
          return [".", "..", ...Object.keys(a.Na)];
        }, symlink(a, b, c) {
          a = O.createNode(a, b, 41471, 0);
          a.link = c;
          return a;
        }, readlink(a) {
          if (40960 !== (a.mode & 61440))
            throw new N(28);
          return a.link;
        } }, Ma: { read(a, b, c, d, e) {
          var h = a.node.Na;
          if (e >= a.node.Ra)
            return 0;
          a = Math.min(a.node.Ra - e, d);
          if (8 < a && h.subarray)
            b.set(h.subarray(e, e + a), c);
          else
            for (d = 0; d < a; d++)
              b[c + d] = h[e + d];
          return a;
        }, write(a, b, c, d, e, h) {
          b.buffer === p.buffer && (h = false);
          if (!d)
            return 0;
          a = a.node;
          a.mtime = a.ctime = Date.now();
          if (b.subarray && (!a.Na || a.Na.subarray)) {
            if (h)
              return a.Na = b.subarray(c, c + d), a.Ra = d;
            if (0 === a.Ra && 0 === e)
              return a.Na = b.slice(c, c + d), a.Ra = d;
            if (e + d <= a.Ra)
              return a.Na.set(b.subarray(
                c,
                c + d
              ), e), d;
          }
          h = e + d;
          var k = a.Na ? a.Na.length : 0;
          k >= h || (h = Math.max(h, k * (1048576 > k ? 2 : 1.125) >>> 0), 0 != k && (h = Math.max(h, 256)), k = a.Na, a.Na = new Uint8Array(h), 0 < a.Ra && a.Na.set(k.subarray(0, a.Ra), 0));
          if (a.Na.subarray && b.subarray)
            a.Na.set(b.subarray(c, c + d), e);
          else
            for (h = 0; h < d; h++)
              a.Na[e + h] = b[c + h];
          a.Ra = Math.max(a.Ra, e + d);
          return d;
        }, Va(a, b, c) {
          1 === c ? b += a.position : 2 === c && 32768 === (a.node.mode & 61440) && (b += a.node.Ra);
          if (0 > b)
            throw new N(28);
          return b;
        }, ib(a, b, c, d, e) {
          if (32768 !== (a.node.mode & 61440))
            throw new N(43);
          a = a.node.Na;
          if (e & 2 || !a || a.buffer !== p.buffer) {
            e = true;
            d = 65536 * Math.ceil(b / 65536);
            var h = Db(65536, d);
            h && x.fill(0, h, h + d);
            d = h;
            if (!d)
              throw new N(48);
            if (a) {
              if (0 < c || c + b < a.length)
                a.subarray ? a = a.subarray(c, c + b) : a = Array.prototype.slice.call(a, c, c + b);
              p.set(a, d);
            }
          } else
            e = false, d = a.byteOffset;
          return { Kb: d, Ab: e };
        }, jb(a, b, c, d) {
          O.Ma.write(a, b, 0, d, c, false);
          return 0;
        } } }, la = (a, b) => {
          var c = 0;
          a && (c |= 365);
          b && (c |= 146);
          return c;
        }, Eb = null, Fb = {}, Gb = [], Hb = 1, R = null, Ib = false, Jb = true, Kb = {}, N = class {
          constructor(a) {
            __publicField(this, "name", "ErrnoError");
            this.Pa = a;
          }
        }, Lb = class {
          constructor() {
            __publicField(this, "gb", {});
            __publicField(this, "node", null);
          }
          get flags() {
            return this.gb.flags;
          }
          set flags(a) {
            this.gb.flags = a;
          }
          get position() {
            return this.gb.position;
          }
          set position(a) {
            this.gb.position = a;
          }
        }, Mb = class {
          constructor(a, b, c, d) {
            __publicField(this, "La", {});
            __publicField(this, "Ma", {});
            __publicField(this, "ab", null);
            a || (a = this);
            this.parent = a;
            this.Xa = a.Xa;
            this.id = Hb++;
            this.name = b;
            this.mode = c;
            this.rdev = d;
            this.atime = this.mtime = this.ctime = Date.now();
          }
          get read() {
            return 365 === (this.mode & 365);
          }
          set read(a) {
            a ? this.mode |= 365 : this.mode &= -366;
          }
          get write() {
            return 146 === (this.mode & 146);
          }
          set write(a) {
            a ? this.mode |= 146 : this.mode &= -147;
          }
        };
        function S(a, b = {}) {
          var _a;
          if (!a)
            throw new N(44);
          (_a = b.nb) != null ? _a : b.nb = true;
          "/" === a.charAt(0) || (a = "//" + a);
          var c = 0;
          a:
            for (; 40 > c; c++) {
              a = a.split("/").filter((q) => !!q);
              for (var d = Eb, e = "/", h = 0; h < a.length; h++) {
                var k = h === a.length - 1;
                if (k && b.parent)
                  break;
                if ("." !== a[h])
                  if (".." === a[h])
                    e = fb(e), d = d.parent;
                  else {
                    e = ka(e + "/" + a[h]);
                    try {
                      d = Q(d, a[h]);
                    } catch (q) {
                      if (44 === (q == null ? void 0 : q.Pa) && k && b.Jb)
                        return { path: e };
                      throw q;
                    }
                    !d.ab || k && !b.nb || (d = d.ab.root);
                    if (40960 === (d.mode & 61440) && (!k || b.$a)) {
                      if (!d.La.readlink)
                        throw new N(52);
                      d = d.La.readlink(d);
                      "/" === d.charAt(0) || (d = fb(e) + "/" + d);
                      a = d + "/" + a.slice(h + 1).join("/");
                      continue a;
                    }
                  }
              }
              return { path: e, node: d };
            }
          throw new N(32);
        }
        function ja(a) {
          for (var b; ; ) {
            if (a === a.parent)
              return a = a.Xa.zb, b ? "/" !== a[a.length - 1] ? `${a}/${b}` : a + b : a;
            b = b ? `${a.name}/${b}` : a.name;
            a = a.parent;
          }
        }
        function Nb(a, b) {
          for (var c = 0, d = 0; d < b.length; d++)
            c = (c << 5) - c + b.charCodeAt(d) | 0;
          return (a + c >>> 0) % R.length;
        }
        function Cb(a) {
          var b = Nb(a.parent.id, a.name);
          if (R[b] === a)
            R[b] = a.bb;
          else
            for (b = R[b]; b; ) {
              if (b.bb === a) {
                b.bb = a.bb;
                break;
              }
              b = b.bb;
            }
        }
        function Q(a, b) {
          var c = P(a.mode) ? (c = Ob(a, "x")) ? c : a.La.lookup ? 0 : 2 : 54;
          if (c)
            throw new N(c);
          for (c = R[Nb(a.id, b)]; c; c = c.bb) {
            var d = c.name;
            if (c.parent.id === a.id && d === b)
              return c;
          }
          return a.La.lookup(a, b);
        }
        function Bb(a, b, c, d) {
          a = new Mb(a, b, c, d);
          b = Nb(a.parent.id, a.name);
          a.bb = R[b];
          return R[b] = a;
        }
        function P(a) {
          return 16384 === (a & 61440);
        }
        function Pb(a) {
          var b = ["r", "w", "rw"][a & 3];
          a & 512 && (b += "w");
          return b;
        }
        function Ob(a, b) {
          if (Jb)
            return 0;
          if (!b.includes("r") || a.mode & 292) {
            if (b.includes("w") && !(a.mode & 146) || b.includes("x") && !(a.mode & 73))
              return 2;
          } else
            return 2;
          return 0;
        }
        function Qb(a, b) {
          if (!P(a.mode))
            return 54;
          try {
            return Q(a, b), 20;
          } catch (c) {
          }
          return Ob(a, "wx");
        }
        function Rb(a, b, c) {
          try {
            var d = Q(a, b);
          } catch (e) {
            return e.Pa;
          }
          if (a = Ob(a, "wx"))
            return a;
          if (c) {
            if (!P(d.mode))
              return 54;
            if (d === d.parent || "/" === ja(d))
              return 10;
          } else if (P(d.mode))
            return 31;
          return 0;
        }
        function Sb(a) {
          if (!a)
            throw new N(63);
          return a;
        }
        function T(a) {
          a = Gb[a];
          if (!a)
            throw new N(8);
          return a;
        }
        function Tb(a, b = -1) {
          a = Object.assign(new Lb(), a);
          if (-1 == b)
            a: {
              for (b = 0; 4096 >= b; b++)
                if (!Gb[b])
                  break a;
              throw new N(33);
            }
          a.fd = b;
          return Gb[b] = a;
        }
        function Ub(a, b = -1) {
          var _a, _b;
          a = Tb(a, b);
          (_b = (_a = a.Ma) == null ? void 0 : _a.Rb) == null ? void 0 : _b.call(_a, a);
          return a;
        }
        function Vb(a, b, c) {
          var d = a == null ? void 0 : a.Ma.Ua;
          a = d ? a : b;
          d != null ? d : d = b.La.Ua;
          Sb(d);
          d(a, c);
        }
        var Ab = { open(a) {
          var _a, _b;
          a.Ma = Fb[a.node.rdev].Ma;
          (_b = (_a = a.Ma).open) == null ? void 0 : _b.call(_a, a);
        }, Va() {
          throw new N(70);
        } };
        function wb(a, b) {
          Fb[a] = { Ma: b };
        }
        function Wb(a, b) {
          var c = "/" === b;
          if (c && Eb)
            throw new N(10);
          if (!c && b) {
            var d = S(b, { nb: false });
            b = d.path;
            d = d.node;
            if (d.ab)
              throw new N(10);
            if (!P(d.mode))
              throw new N(54);
          }
          b = { type: a, Wb: {}, zb: b, Ib: [] };
          a = a.Xa(b);
          a.Xa = b;
          b.root = a;
          c ? Eb = a : d && (d.ab = b, d.Xa && d.Xa.Ib.push(b));
        }
        function Xb(a, b, c) {
          var d = S(a, { parent: true }).node;
          a = gb(a);
          if (!a)
            throw new N(28);
          if ("." === a || ".." === a)
            throw new N(20);
          var e = Qb(d, a);
          if (e)
            throw new N(e);
          if (!d.La.hb)
            throw new N(63);
          return d.La.hb(d, a, b, c);
        }
        function ma(a, b = 438) {
          return Xb(a, b & 4095 | 32768, 0);
        }
        function U(a, b = 511) {
          return Xb(a, b & 1023 | 16384, 0);
        }
        function Yb(a, b, c) {
          "undefined" == typeof c && (c = b, b = 438);
          Xb(a, b | 8192, c);
        }
        function Zb(a, b) {
          if (!jb(a))
            throw new N(44);
          var c = S(b, { parent: true }).node;
          if (!c)
            throw new N(44);
          b = gb(b);
          var d = Qb(c, b);
          if (d)
            throw new N(d);
          if (!c.La.symlink)
            throw new N(63);
          c.La.symlink(c, b, a);
        }
        function $b(a) {
          var b = S(a, { parent: true }).node;
          a = gb(a);
          var c = Q(b, a), d = Rb(b, a, true);
          if (d)
            throw new N(d);
          if (!b.La.rmdir)
            throw new N(63);
          if (c.ab)
            throw new N(10);
          b.La.rmdir(b, a);
          Cb(c);
        }
        function za(a) {
          var b = S(a, { parent: true }).node;
          if (!b)
            throw new N(44);
          a = gb(a);
          var c = Q(b, a), d = Rb(b, a, false);
          if (d)
            throw new N(d);
          if (!b.La.unlink)
            throw new N(63);
          if (c.ab)
            throw new N(10);
          b.La.unlink(b, a);
          Cb(c);
        }
        function ac(a, b) {
          a = S(a, { $a: !b }).node;
          return Sb(a.La.Ta)(a);
        }
        function bc(a, b, c, d) {
          Vb(a, b, { mode: c & 4095 | b.mode & -4096, ctime: Date.now(), Fb: d });
        }
        function na(a, b) {
          a = "string" == typeof a ? S(a, { $a: true }).node : a;
          bc(null, a, b);
        }
        function cc(a, b, c) {
          if (P(b.mode))
            throw new N(31);
          if (32768 !== (b.mode & 61440))
            throw new N(28);
          var d = Ob(b, "w");
          if (d)
            throw new N(d);
          Vb(a, b, { size: c, timestamp: Date.now() });
        }
        function oa(a, b, c = 438) {
          if ("" === a)
            throw new N(44);
          if ("string" == typeof b) {
            var d = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }[b];
            if ("undefined" == typeof d)
              throw Error(`Unknown file open mode: ${b}`);
            b = d;
          }
          c = b & 64 ? c & 4095 | 32768 : 0;
          if ("object" == typeof a)
            d = a;
          else {
            var e = a.endsWith("/");
            a = S(a, { $a: !(b & 131072), Jb: true });
            d = a.node;
            a = a.path;
          }
          var h = false;
          if (b & 64)
            if (d) {
              if (b & 128)
                throw new N(20);
            } else {
              if (e)
                throw new N(31);
              d = Xb(a, c | 511, 0);
              h = true;
            }
          if (!d)
            throw new N(44);
          8192 === (d.mode & 61440) && (b &= -513);
          if (b & 65536 && !P(d.mode))
            throw new N(54);
          if (!h && (e = d ? 40960 === (d.mode & 61440) ? 32 : P(d.mode) && ("r" !== Pb(b) || b & 576) ? 31 : Ob(d, Pb(b)) : 44))
            throw new N(e);
          b & 512 && !h && (e = d, e = "string" == typeof e ? S(e, { $a: true }).node : e, cc(null, e, 0));
          b &= -131713;
          e = Tb({ node: d, path: ja(d), flags: b, seekable: true, position: 0, Ma: d.Ma, Lb: [], error: false });
          e.Ma.open && e.Ma.open(e);
          h && na(d, c & 511);
          !f.logReadFiles || b & 1 || a in Kb || (Kb[a] = 1);
          return e;
        }
        function qa(a) {
          if (null === a.fd)
            throw new N(8);
          a.ob && (a.ob = null);
          try {
            a.Ma.close && a.Ma.close(a);
          } catch (b) {
            throw b;
          } finally {
            Gb[a.fd] = null;
          }
          a.fd = null;
        }
        function mc(a, b, c) {
          if (null === a.fd)
            throw new N(8);
          if (!a.seekable || !a.Ma.Va)
            throw new N(70);
          if (0 != c && 1 != c && 2 != c)
            throw new N(28);
          a.position = a.Ma.Va(a, b, c);
          a.Lb = [];
        }
        function Ec(a, b, c, d, e) {
          if (0 > d || 0 > e)
            throw new N(28);
          if (null === a.fd)
            throw new N(8);
          if (1 === (a.flags & 2097155))
            throw new N(8);
          if (P(a.node.mode))
            throw new N(31);
          if (!a.Ma.read)
            throw new N(28);
          var h = "undefined" != typeof e;
          if (!h)
            e = a.position;
          else if (!a.seekable)
            throw new N(70);
          b = a.Ma.read(a, b, c, d, e);
          h || (a.position += b);
          return b;
        }
        function pa(a, b, c, d, e) {
          if (0 > d || 0 > e)
            throw new N(28);
          if (null === a.fd)
            throw new N(8);
          if (0 === (a.flags & 2097155))
            throw new N(8);
          if (P(a.node.mode))
            throw new N(31);
          if (!a.Ma.write)
            throw new N(28);
          a.seekable && a.flags & 1024 && mc(a, 0, 2);
          var h = "undefined" != typeof e;
          if (!h)
            e = a.position;
          else if (!a.seekable)
            throw new N(70);
          b = a.Ma.write(a, b, c, d, e, void 0);
          h || (a.position += b);
          return b;
        }
        function ya(a) {
          var b = "binary";
          if ("utf8" !== b && "binary" !== b)
            throw Error(`Invalid encoding type "${b}"`);
          var c;
          var d = oa(a, d || 0);
          a = ac(a).size;
          var e = new Uint8Array(a);
          Ec(d, e, 0, a, 0);
          "utf8" === b ? c = B(e) : "binary" === b && (c = e);
          qa(d);
          return c;
        }
        function V(a, b, c) {
          var _a;
          a = ka("/dev/" + a);
          var d = la(!!b, !!c);
          (_a = V.yb) != null ? _a : V.yb = 64;
          var e = V.yb++ << 8 | 0;
          wb(e, { open(h) {
            h.seekable = false;
          }, close() {
            var _a2;
            ((_a2 = c == null ? void 0 : c.buffer) == null ? void 0 : _a2.length) && c(10);
          }, read(h, k, q, w) {
            for (var v = 0, C = 0; C < w; C++) {
              try {
                var G = b();
              } catch (pb) {
                throw new N(29);
              }
              if (void 0 === G && 0 === v)
                throw new N(6);
              if (null === G || void 0 === G)
                break;
              v++;
              k[q + C] = G;
            }
            v && (h.node.atime = Date.now());
            return v;
          }, write(h, k, q, w) {
            for (var v = 0; v < w; v++)
              try {
                c(k[q + v]);
              } catch (C) {
                throw new N(29);
              }
            w && (h.node.mtime = h.node.ctime = Date.now());
            return v;
          } });
          Yb(a, d, e);
        }
        var W = {};
        function Gc(a, b, c) {
          if ("/" === b.charAt(0))
            return b;
          a = -100 === a ? "/" : T(a).path;
          if (0 == b.length) {
            if (!c)
              throw new N(44);
            return a;
          }
          return a + "/" + b;
        }
        function Hc(a, b) {
          E[a >> 2] = b.dev;
          E[a + 4 >> 2] = b.mode;
          F[a + 8 >> 2] = b.nlink;
          E[a + 12 >> 2] = b.uid;
          E[a + 16 >> 2] = b.gid;
          E[a + 20 >> 2] = b.rdev;
          H[a + 24 >> 3] = BigInt(b.size);
          E[a + 32 >> 2] = 4096;
          E[a + 36 >> 2] = b.blocks;
          var c = b.atime.getTime(), d = b.mtime.getTime(), e = b.ctime.getTime();
          H[a + 40 >> 3] = BigInt(Math.floor(c / 1e3));
          F[a + 48 >> 2] = c % 1e3 * 1e6;
          H[a + 56 >> 3] = BigInt(Math.floor(d / 1e3));
          F[a + 64 >> 2] = d % 1e3 * 1e6;
          H[a + 72 >> 3] = BigInt(Math.floor(e / 1e3));
          F[a + 80 >> 2] = e % 1e3 * 1e6;
          H[a + 88 >> 3] = BigInt(b.ino);
          return 0;
        }
        var Ic = void 0, Jc = () => {
          var a = E[+Ic >> 2];
          Ic += 4;
          return a;
        }, Kc = 0, Lc = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Mc = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Nc = {}, Oc = (a) => {
          var _a;
          Ma = a;
          cb || 0 < Kc || ((_a = f.onExit) == null ? void 0 : _a.call(f, a), La = true);
          Da(a, new Ya(a));
        }, Pc = (a) => {
          if (!La)
            try {
              if (a(), !(cb || 0 < Kc))
                try {
                  Ma = a = Ma, Oc(a);
                } catch (b) {
                  b instanceof Ya || "unwind" == b || Da(1, b);
                }
            } catch (b) {
              b instanceof Ya || "unwind" == b || Da(1, b);
            }
        }, Qc = {}, Sc = () => {
          if (!Rc) {
            var a = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: Ca || "./this.program" }, b;
            for (b in Qc)
              void 0 === Qc[b] ? delete a[b] : a[b] = Qc[b];
            var c = [];
            for (b in a)
              c.push(`${b}=${a[b]}`);
            Rc = c;
          }
          return Rc;
        }, Rc, xa = (a) => {
          var b = ha(a) + 1, c = z(b);
          u(a, x, c, b);
          return c;
        }, Tc = (a, b, c, d) => {
          var e = { string: (v) => {
            var C = 0;
            null !== v && void 0 !== v && 0 !== v && (C = xa(v));
            return C;
          }, array: (v) => {
            var C = z(v.length);
            p.set(v, C);
            return C;
          } };
          a = f["_" + a];
          var h = [], k = 0;
          if (d)
            for (var q = 0; q < d.length; q++) {
              var w = e[c[q]];
              w ? (0 === k && (k = sa()), h[q] = w(d[q])) : h[q] = d[q];
            }
          c = a(...h);
          return c = function(v) {
            0 !== k && wa(k);
            return "string" === b ? v ? B(x, v) : "" : "boolean" === b ? !!v : v;
          }(c);
        }, ea = 0, da = (a, b) => {
          b = 1 == b ? z(a.length) : ia(a.length);
          a.subarray || a.slice || (a = new Uint8Array(a));
          x.set(a, b);
          return b;
        }, Uc, Vc = [], Y, A = (a) => {
          Uc.delete(Y.get(a));
          Y.set(a, null);
          Vc.push(a);
        }, Aa = (a, b) => {
          if (!Uc) {
            Uc = /* @__PURE__ */ new WeakMap();
            var c = Y.length;
            if (Uc)
              for (var d = 0; d < 0 + c; d++) {
                var e = Y.get(d);
                e && Uc.set(e, d);
              }
          }
          if (c = Uc.get(a) || 0)
            return c;
          if (Vc.length)
            c = Vc.pop();
          else {
            try {
              Y.grow(1);
            } catch (w) {
              if (!(w instanceof RangeError))
                throw w;
              throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            c = Y.length - 1;
          }
          try {
            Y.set(c, a);
          } catch (w) {
            if (!(w instanceof TypeError))
              throw w;
            if ("function" == typeof WebAssembly.Function) {
              var h = WebAssembly.Function;
              d = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" };
              e = { parameters: [], results: "v" == b[0] ? [] : [d[b[0]]] };
              for (var k = 1; k < b.length; ++k)
                e.parameters.push(d[b[k]]);
              b = new h(e, a);
            } else {
              d = [1];
              e = b.slice(0, 1);
              b = b.slice(1);
              k = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
              d.push(96);
              var q = b.length;
              128 > q ? d.push(q) : d.push(q % 128 | 128, q >> 7);
              for (h of b)
                d.push(k[h]);
              "v" == e ? d.push(0) : d.push(1, k[e]);
              b = [0, 97, 115, 109, 1, 0, 0, 0, 1];
              h = d.length;
              128 > h ? b.push(h) : b.push(h % 128 | 128, h >> 7);
              b.push(...d);
              b.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
              b = new WebAssembly.Module(new Uint8Array(b));
              b = new WebAssembly.Instance(b, { e: { f: a } }).exports.f;
            }
            Y.set(c, b);
          }
          Uc.set(a, c);
          return c;
        };
        R = Array(4096);
        Wb(O, "/");
        U("/tmp");
        U("/home");
        U("/home/web_user");
        (function() {
          U("/dev");
          wb(259, { read: () => 0, write: (d, e, h, k) => k, Va: () => 0 });
          Yb("/dev/null", 259);
          nb(1280, yb);
          nb(1536, zb);
          Yb("/dev/tty", 1280);
          Yb("/dev/tty1", 1536);
          var a = new Uint8Array(1024), b = 0, c = () => {
            0 === b && (ib(a), b = a.byteLength);
            return a[--b];
          };
          V("random", c);
          V("urandom", c);
          U("/dev/shm");
          U("/dev/shm/tmp");
        })();
        (function() {
          U("/proc");
          var a = U("/proc/self");
          U("/proc/self/fd");
          Wb({ Xa() {
            var b = Bb(a, "fd", 16895, 73);
            b.Ma = { Va: O.Ma.Va };
            b.La = { lookup(c, d) {
              c = +d;
              var e = T(c);
              c = { parent: null, Xa: { zb: "fake" }, La: { readlink: () => e.path }, id: c + 1 };
              return c.parent = c;
            }, readdir() {
              return Array.from(Gb.entries()).filter(([, c]) => c).map(([c]) => c.toString());
            } };
            return b;
          } }, "/proc/self/fd");
        })();
        O.vb = new N(44);
        O.vb.stack = "<generic error, no stack>";
        var Xc = { a: (a, b, c, d) => Ta(`Assertion failed: ${a ? B(x, a) : ""}, at: ` + [b ? b ? B(x, b) : "" : "unknown filename", c, d ? d ? B(x, d) : "" : "unknown function"]), i: function(a, b) {
          try {
            return a = a ? B(x, a) : "", na(a, b), 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return -c.Pa;
          }
        }, L: function(a, b, c) {
          try {
            b = b ? B(x, b) : "";
            b = Gc(a, b);
            if (c & -8)
              return -28;
            var d = S(b, { $a: true }).node;
            if (!d)
              return -44;
            a = "";
            c & 4 && (a += "r");
            c & 2 && (a += "w");
            c & 1 && (a += "x");
            return a && Ob(d, a) ? -2 : 0;
          } catch (e) {
            if ("undefined" == typeof W || "ErrnoError" !== e.name)
              throw e;
            return -e.Pa;
          }
        }, j: function(a, b) {
          try {
            var c = T(a);
            bc(c, c.node, b, false);
            return 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, h: function(a) {
          try {
            var b = T(a);
            Vb(b, b.node, { timestamp: Date.now(), Fb: false });
            return 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return -c.Pa;
          }
        }, b: function(a, b, c) {
          Ic = c;
          try {
            var d = T(a);
            switch (b) {
              case 0:
                var e = Jc();
                if (0 > e)
                  break;
                for (; Gb[e]; )
                  e++;
                return Ub(d, e).fd;
              case 1:
              case 2:
                return 0;
              case 3:
                return d.flags;
              case 4:
                return e = Jc(), d.flags |= e, 0;
              case 12:
                return e = Jc(), Na[e + 0 >> 1] = 2, 0;
              case 13:
              case 14:
                return 0;
            }
            return -28;
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name)
              throw h;
            return -h.Pa;
          }
        }, g: function(a, b) {
          try {
            var c = T(a), d = c.node, e = c.Ma.Ta;
            a = e ? c : d;
            e != null ? e : e = d.La.Ta;
            Sb(e);
            var h = e(a);
            return Hc(b, h);
          } catch (k) {
            if ("undefined" == typeof W || "ErrnoError" !== k.name)
              throw k;
            return -k.Pa;
          }
        }, H: function(a, b) {
          b = -9007199254740992 > b || 9007199254740992 < b ? NaN : Number(b);
          try {
            if (isNaN(b))
              return 61;
            var c = T(a);
            if (0 > b || 0 === (c.flags & 2097155))
              throw new N(28);
            cc(c, c.node, b);
            return 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, G: function(a, b) {
          try {
            if (0 === b)
              return -28;
            var c = ha("/") + 1;
            if (b < c)
              return -68;
            u("/", x, a, b);
            return c;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, K: function(a, b) {
          try {
            return a = a ? B(x, a) : "", Hc(b, ac(a, true));
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return -c.Pa;
          }
        }, C: function(a, b, c) {
          try {
            return b = b ? B(x, b) : "", b = Gc(a, b), U(b, c), 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, J: function(a, b, c, d) {
          try {
            b = b ? B(x, b) : "";
            var e = d & 256;
            b = Gc(a, b, d & 4096);
            return Hc(c, e ? ac(b, true) : ac(b));
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name)
              throw h;
            return -h.Pa;
          }
        }, x: function(a, b, c, d) {
          Ic = d;
          try {
            b = b ? B(x, b) : "";
            b = Gc(a, b);
            var e = d ? Jc() : 0;
            return oa(b, c, e).fd;
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name)
              throw h;
            return -h.Pa;
          }
        }, v: function(a, b, c, d) {
          try {
            b = b ? B(x, b) : "";
            b = Gc(a, b);
            if (0 >= d)
              return -28;
            var e = S(b).node;
            if (!e)
              throw new N(44);
            if (!e.La.readlink)
              throw new N(28);
            var h = e.La.readlink(e);
            var k = Math.min(d, ha(h)), q = p[c + k];
            u(h, x, c, d + 1);
            p[c + k] = q;
            return k;
          } catch (w) {
            if ("undefined" == typeof W || "ErrnoError" !== w.name)
              throw w;
            return -w.Pa;
          }
        }, u: function(a) {
          try {
            return a = a ? B(x, a) : "", $b(a), 0;
          } catch (b) {
            if ("undefined" == typeof W || "ErrnoError" !== b.name)
              throw b;
            return -b.Pa;
          }
        }, f: function(a, b) {
          try {
            return a = a ? B(x, a) : "", Hc(b, ac(a));
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return -c.Pa;
          }
        }, r: function(a, b, c) {
          try {
            return b = b ? B(x, b) : "", b = Gc(a, b), 0 === c ? za(b) : 512 === c ? $b(b) : Ta("Invalid flags passed to unlinkat"), 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return -d.Pa;
          }
        }, q: function(a, b, c) {
          try {
            b = b ? B(x, b) : "";
            b = Gc(a, b, true);
            var d = Date.now(), e, h;
            if (c) {
              var k = F[c >> 2] + 4294967296 * E[c + 4 >> 2], q = E[c + 8 >> 2];
              1073741823 == q ? e = d : 1073741822 == q ? e = null : e = 1e3 * k + q / 1e6;
              c += 16;
              k = F[c >> 2] + 4294967296 * E[c + 4 >> 2];
              q = E[c + 8 >> 2];
              1073741823 == q ? h = d : 1073741822 == q ? h = null : h = 1e3 * k + q / 1e6;
            } else
              h = e = d;
            if (null !== (h != null ? h : e)) {
              a = e;
              var w = S(b, { $a: true }).node;
              Sb(w.La.Ua)(w, { atime: a, mtime: h });
            }
            return 0;
          } catch (v) {
            if ("undefined" == typeof W || "ErrnoError" !== v.name)
              throw v;
            return -v.Pa;
          }
        }, m: () => Ta(""), l: () => {
          cb = false;
          Kc = 0;
        }, A: function(a, b) {
          a = -9007199254740992 > a || 9007199254740992 < a ? NaN : Number(a);
          a = new Date(1e3 * a);
          E[b >> 2] = a.getSeconds();
          E[b + 4 >> 2] = a.getMinutes();
          E[b + 8 >> 2] = a.getHours();
          E[b + 12 >> 2] = a.getDate();
          E[b + 16 >> 2] = a.getMonth();
          E[b + 20 >> 2] = a.getFullYear() - 1900;
          E[b + 24 >> 2] = a.getDay();
          var c = a.getFullYear();
          E[b + 28 >> 2] = (0 !== c % 4 || 0 === c % 100 && 0 !== c % 400 ? Mc : Lc)[a.getMonth()] + a.getDate() - 1 | 0;
          E[b + 36 >> 2] = -(60 * a.getTimezoneOffset());
          c = new Date(
            a.getFullYear(),
            6,
            1
          ).getTimezoneOffset();
          var d = new Date(a.getFullYear(), 0, 1).getTimezoneOffset();
          E[b + 32 >> 2] = (c != d && a.getTimezoneOffset() == Math.min(d, c)) | 0;
        }, y: function(a, b, c, d, e, h, k) {
          e = -9007199254740992 > e || 9007199254740992 < e ? NaN : Number(e);
          try {
            if (isNaN(e))
              return 61;
            var q = T(d);
            if (0 !== (b & 2) && 0 === (c & 2) && 2 !== (q.flags & 2097155))
              throw new N(2);
            if (1 === (q.flags & 2097155))
              throw new N(2);
            if (!q.Ma.ib)
              throw new N(43);
            if (!a)
              throw new N(28);
            var w = q.Ma.ib(q, a, e, b, c);
            var v = w.Kb;
            E[h >> 2] = w.Ab;
            F[k >> 2] = v;
            return 0;
          } catch (C) {
            if ("undefined" == typeof W || "ErrnoError" !== C.name)
              throw C;
            return -C.Pa;
          }
        }, z: function(a, b, c, d, e, h) {
          h = -9007199254740992 > h || 9007199254740992 < h ? NaN : Number(h);
          try {
            var k = T(e);
            if (c & 2) {
              c = h;
              if (32768 !== (k.node.mode & 61440))
                throw new N(43);
              if (!(d & 2)) {
                var q = x.slice(a, a + b);
                k.Ma.jb && k.Ma.jb(k, q, c, b, d);
              }
            }
          } catch (w) {
            if ("undefined" == typeof W || "ErrnoError" !== w.name)
              throw w;
            return -w.Pa;
          }
        }, n: (a, b) => {
          Nc[a] && (clearTimeout(Nc[a].id), delete Nc[a]);
          if (!b)
            return 0;
          var c = setTimeout(() => {
            delete Nc[a];
            Pc(() => Wc(a, performance.now()));
          }, b);
          Nc[a] = {
            id: c,
            Xb: b
          };
          return 0;
        }, B: (a, b, c, d) => {
          var e = (/* @__PURE__ */ new Date()).getFullYear(), h = new Date(e, 0, 1).getTimezoneOffset();
          e = new Date(e, 6, 1).getTimezoneOffset();
          F[a >> 2] = 60 * Math.max(h, e);
          E[b >> 2] = Number(h != e);
          b = (k) => {
            var q = Math.abs(k);
            return `UTC${0 <= k ? "-" : "+"}${String(Math.floor(q / 60)).padStart(2, "0")}${String(q % 60).padStart(2, "0")}`;
          };
          a = b(h);
          b = b(e);
          e < h ? (u(a, x, c, 17), u(b, x, d, 17)) : (u(a, x, d, 17), u(b, x, c, 17));
        }, d: () => Date.now(), s: () => 2147483648, c: () => performance.now(), o: (a) => {
          var b = x.length;
          a >>>= 0;
          if (2147483648 < a)
            return false;
          for (var c = 1; 4 >= c; c *= 2) {
            var d = b * (1 + 0.2 / c);
            d = Math.min(d, a + 100663296);
            a: {
              d = (Math.min(2147483648, 65536 * Math.ceil(Math.max(a, d) / 65536)) - Ka.buffer.byteLength + 65535) / 65536 | 0;
              try {
                Ka.grow(d);
                Qa();
                var e = 1;
                break a;
              } catch (h) {
              }
              e = void 0;
            }
            if (e)
              return true;
          }
          return false;
        }, E: (a, b) => {
          var c = 0;
          Sc().forEach((d, e) => {
            var h = b + c;
            e = F[a + 4 * e >> 2] = h;
            for (h = 0; h < d.length; ++h)
              p[e++] = d.charCodeAt(h);
            p[e] = 0;
            c += d.length + 1;
          });
          return 0;
        }, F: (a, b) => {
          var c = Sc();
          F[a >> 2] = c.length;
          var d = 0;
          c.forEach((e) => d += e.length + 1);
          F[b >> 2] = d;
          return 0;
        }, e: function(a) {
          try {
            var b = T(a);
            qa(b);
            return 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return c.Pa;
          }
        }, p: function(a, b) {
          try {
            var c = T(a);
            p[b] = c.tty ? 2 : P(c.mode) ? 3 : 40960 === (c.mode & 61440) ? 7 : 4;
            Na[b + 2 >> 1] = 0;
            H[b + 8 >> 3] = BigInt(0);
            H[b + 16 >> 3] = BigInt(0);
            return 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name)
              throw d;
            return d.Pa;
          }
        }, w: function(a, b, c, d) {
          try {
            a: {
              var e = T(a);
              a = b;
              for (var h, k = b = 0; k < c; k++) {
                var q = F[a >> 2], w = F[a + 4 >> 2];
                a += 8;
                var v = Ec(e, p, q, w, h);
                if (0 > v) {
                  var C = -1;
                  break a;
                }
                b += v;
                if (v < w)
                  break;
                "undefined" != typeof h && (h += v);
              }
              C = b;
            }
            F[d >> 2] = C;
            return 0;
          } catch (G) {
            if ("undefined" == typeof W || "ErrnoError" !== G.name)
              throw G;
            return G.Pa;
          }
        }, D: function(a, b, c, d) {
          b = -9007199254740992 > b || 9007199254740992 < b ? NaN : Number(b);
          try {
            if (isNaN(b))
              return 61;
            var e = T(a);
            mc(e, b, c);
            H[d >> 3] = BigInt(e.position);
            e.ob && 0 === b && 0 === c && (e.ob = null);
            return 0;
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name)
              throw h;
            return h.Pa;
          }
        }, I: function(a) {
          var _a;
          try {
            var b = T(a);
            return ((_a = b.Ma) == null ? void 0 : _a.fsync) ? b.Ma.fsync(b) : 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name)
              throw c;
            return c.Pa;
          }
        }, t: function(a, b, c, d) {
          try {
            a: {
              var e = T(a);
              a = b;
              for (var h, k = b = 0; k < c; k++) {
                var q = F[a >> 2], w = F[a + 4 >> 2];
                a += 8;
                var v = pa(e, p, q, w, h);
                if (0 > v) {
                  var C = -1;
                  break a;
                }
                b += v;
                if (v < w)
                  break;
                "undefined" != typeof h && (h += v);
              }
              C = b;
            }
            F[d >> 2] = C;
            return 0;
          } catch (G) {
            if ("undefined" == typeof W || "ErrnoError" !== G.name)
              throw G;
            return G.Pa;
          }
        }, k: Oc }, Z;
        (async function() {
          var _a;
          function a(c) {
            var _a2;
            Z = c.exports;
            Ka = Z.M;
            Qa();
            Y = Z.O;
            K--;
            (_a2 = f.monitorRunDependencies) == null ? void 0 : _a2.call(f, K);
            0 == K && Sa && (c = Sa, Sa = null, c());
            return Z;
          }
          K++;
          (_a = f.monitorRunDependencies) == null ? void 0 : _a.call(f, K);
          var b = { a: Xc };
          if (f.instantiateWasm)
            return new Promise((c) => {
              f.instantiateWasm(b, (d, e) => {
                a(d, e);
                c(d.exports);
              });
            });
          Ua != null ? Ua : Ua = f.locateFile ? f.locateFile("sql-wasm.wasm", D) : D + "sql-wasm.wasm";
          return a((await Xa(b)).instance);
        })();
        f._sqlite3_free = (a) => (f._sqlite3_free = Z.P)(a);
        f._sqlite3_value_text = (a) => (f._sqlite3_value_text = Z.Q)(a);
        f._sqlite3_prepare_v2 = (a, b, c, d, e) => (f._sqlite3_prepare_v2 = Z.R)(a, b, c, d, e);
        f._sqlite3_step = (a) => (f._sqlite3_step = Z.S)(a);
        f._sqlite3_reset = (a) => (f._sqlite3_reset = Z.T)(a);
        f._sqlite3_exec = (a, b, c, d, e) => (f._sqlite3_exec = Z.U)(a, b, c, d, e);
        f._sqlite3_finalize = (a) => (f._sqlite3_finalize = Z.V)(a);
        f._sqlite3_column_name = (a, b) => (f._sqlite3_column_name = Z.W)(a, b);
        f._sqlite3_column_text = (a, b) => (f._sqlite3_column_text = Z.X)(a, b);
        f._sqlite3_column_type = (a, b) => (f._sqlite3_column_type = Z.Y)(a, b);
        f._sqlite3_errmsg = (a) => (f._sqlite3_errmsg = Z.Z)(a);
        f._sqlite3_clear_bindings = (a) => (f._sqlite3_clear_bindings = Z._)(a);
        f._sqlite3_value_blob = (a) => (f._sqlite3_value_blob = Z.$)(a);
        f._sqlite3_value_bytes = (a) => (f._sqlite3_value_bytes = Z.aa)(a);
        f._sqlite3_value_double = (a) => (f._sqlite3_value_double = Z.ba)(a);
        f._sqlite3_value_int = (a) => (f._sqlite3_value_int = Z.ca)(a);
        f._sqlite3_value_type = (a) => (f._sqlite3_value_type = Z.da)(a);
        f._sqlite3_result_blob = (a, b, c, d) => (f._sqlite3_result_blob = Z.ea)(a, b, c, d);
        f._sqlite3_result_double = (a, b) => (f._sqlite3_result_double = Z.fa)(a, b);
        f._sqlite3_result_error = (a, b, c) => (f._sqlite3_result_error = Z.ga)(a, b, c);
        f._sqlite3_result_int = (a, b) => (f._sqlite3_result_int = Z.ha)(a, b);
        f._sqlite3_result_int64 = (a, b) => (f._sqlite3_result_int64 = Z.ia)(a, b);
        f._sqlite3_result_null = (a) => (f._sqlite3_result_null = Z.ja)(a);
        f._sqlite3_result_text = (a, b, c, d) => (f._sqlite3_result_text = Z.ka)(a, b, c, d);
        f._sqlite3_aggregate_context = (a, b) => (f._sqlite3_aggregate_context = Z.la)(a, b);
        f._sqlite3_column_count = (a) => (f._sqlite3_column_count = Z.ma)(a);
        f._sqlite3_data_count = (a) => (f._sqlite3_data_count = Z.na)(a);
        f._sqlite3_column_blob = (a, b) => (f._sqlite3_column_blob = Z.oa)(a, b);
        f._sqlite3_column_bytes = (a, b) => (f._sqlite3_column_bytes = Z.pa)(a, b);
        f._sqlite3_column_double = (a, b) => (f._sqlite3_column_double = Z.qa)(a, b);
        f._sqlite3_bind_blob = (a, b, c, d, e) => (f._sqlite3_bind_blob = Z.ra)(a, b, c, d, e);
        f._sqlite3_bind_double = (a, b, c) => (f._sqlite3_bind_double = Z.sa)(a, b, c);
        f._sqlite3_bind_int = (a, b, c) => (f._sqlite3_bind_int = Z.ta)(a, b, c);
        f._sqlite3_bind_text = (a, b, c, d, e) => (f._sqlite3_bind_text = Z.ua)(a, b, c, d, e);
        f._sqlite3_bind_parameter_index = (a, b) => (f._sqlite3_bind_parameter_index = Z.va)(a, b);
        f._sqlite3_sql = (a) => (f._sqlite3_sql = Z.wa)(a);
        f._sqlite3_normalized_sql = (a) => (f._sqlite3_normalized_sql = Z.xa)(a);
        f._sqlite3_changes = (a) => (f._sqlite3_changes = Z.ya)(a);
        f._sqlite3_close_v2 = (a) => (f._sqlite3_close_v2 = Z.za)(a);
        f._sqlite3_create_function_v2 = (a, b, c, d, e, h, k, q, w) => (f._sqlite3_create_function_v2 = Z.Aa)(a, b, c, d, e, h, k, q, w);
        f._sqlite3_update_hook = (a, b, c) => (f._sqlite3_update_hook = Z.Ba)(a, b, c);
        f._sqlite3_open = (a, b) => (f._sqlite3_open = Z.Ca)(a, b);
        var ia = f._malloc = (a) => (ia = f._malloc = Z.Da)(a), fa = f._free = (a) => (fa = f._free = Z.Ea)(a);
        f._RegisterExtensionFunctions = (a) => (f._RegisterExtensionFunctions = Z.Fa)(a);
        var Db = (a, b) => (Db = Z.Ga)(a, b), Wc = (a, b) => (Wc = Z.Ha)(a, b), wa = (a) => (wa = Z.Ia)(a), z = (a) => (z = Z.Ja)(a), sa = () => (sa = Z.Ka)();
        f.stackSave = () => sa();
        f.stackRestore = (a) => wa(a);
        f.stackAlloc = (a) => z(a);
        f.cwrap = (a, b, c, d) => {
          var e = !c || c.every((h) => "number" === h || "boolean" === h);
          return "string" !== b && e && !d ? f["_" + a] : (...h) => Tc(a, b, c, h);
        };
        f.addFunction = Aa;
        f.removeFunction = A;
        f.UTF8ToString = ua;
        f.ALLOC_NORMAL = ea;
        f.allocate = da;
        f.allocateUTF8OnStack = xa;
        function Yc() {
          function a() {
            var _a;
            f.calledRun = true;
            if (!La) {
              if (!f.noFSInit && !Ib) {
                var b, c;
                Ib = true;
                d != null ? d : d = f.stdin;
                b != null ? b : b = f.stdout;
                c != null ? c : c = f.stderr;
                d ? V("stdin", d) : Zb("/dev/tty", "/dev/stdin");
                b ? V("stdout", null, b) : Zb("/dev/tty", "/dev/stdout");
                c ? V("stderr", null, c) : Zb("/dev/tty1", "/dev/stderr");
                oa("/dev/stdin", 0);
                oa("/dev/stdout", 1);
                oa("/dev/stderr", 1);
              }
              Z.N();
              Jb = false;
              (_a = f.onRuntimeInitialized) == null ? void 0 : _a.call(f);
              if (f.postRun)
                for ("function" == typeof f.postRun && (f.postRun = [f.postRun]); f.postRun.length; ) {
                  var d = f.postRun.shift();
                  $a.unshift(d);
                }
              Za($a);
            }
          }
          if (0 < K)
            Sa = Yc;
          else {
            if (f.preRun)
              for ("function" == typeof f.preRun && (f.preRun = [f.preRun]); f.preRun.length; )
                bb();
            Za(ab);
            0 < K ? Sa = Yc : f.setStatus ? (f.setStatus("Running..."), setTimeout(() => {
              setTimeout(() => f.setStatus(""), 1);
              a();
            }, 1)) : a();
          }
        }
        if (f.preInit)
          for ("function" == typeof f.preInit && (f.preInit = [f.preInit]); 0 < f.preInit.length; )
            f.preInit.pop()();
        Yc();
        return Module;
      });
      return initSqlJsPromise;
    };
    if (typeof exports === "object" && typeof module2 === "object") {
      module2.exports = initSqlJs3;
      module2.exports.default = initSqlJs3;
    } else if (typeof define === "function" && define["amd"]) {
      define([], function() {
        return initSqlJs3;
      });
    } else if (typeof exports === "object") {
      exports["Module"] = initSqlJs3;
    }
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MoonSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  syncPath: "",
  outputFolder: "Books",
  syncOnStartup: true,
  watchForChanges: false,
  showRibbonIcon: true,
  showDescription: true,
  showReadingProgress: true,
  showHighlightColors: true,
  showCovers: true,
  showIndex: true,
  indexNoteTitle: "1. Library Index",
  generateBaseFile: true,
  baseFileName: "2. Books Database",
  showCoverCollage: true,
  coverCollageLimit: 0,
  // 0 = show all
  coverCollageSort: "alpha",
  trackBooksWithoutHighlights: false,
  hardcoverEnabled: false,
  hardcoverToken: ""
};
function getCalloutType(colorInt) {
  const r = colorInt >> 16 & 255;
  const g = colorInt >> 8 & 255;
  const b = colorInt & 255;
  if (r > 200 && g > 200 && b < 100) {
    return "quote";
  }
  if (b > r && b > g && b > 150) {
    return "info";
  }
  if (g > r && g > b && g > 150) {
    return "tip";
  }
  if (r > g && r > b && r > 150) {
    return "warning";
  }
  if (r > 200 && g > 100 && g < 200 && b < 100) {
    return "warning";
  }
  return "quote";
}
function formatDuration(ms) {
  const totalMinutes = Math.floor(ms / 6e4);
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
}
function formatDate(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric"
  });
}

// src/settings.ts
var import_obsidian2 = require("obsidian");
var import_fs = require("fs");
var import_path = require("path");
var import_child_process = require("child_process");
var import_os = require("os");
var MoonSyncSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.activeTab = "configuration";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const tabNav = containerEl.createDiv({ cls: "moonsync-tab-nav" });
    const tabs = [
      { id: "configuration", name: "Configuration" },
      { id: "content", name: "Content" },
      { id: "index-base", name: "Index & base" },
      { id: "integrations", name: "Hardcover" },
      { id: "about", name: "About" }
    ];
    tabs.forEach((tab) => {
      const tabButton = tabNav.createEl("button", {
        text: tab.name,
        cls: this.activeTab === tab.id ? "moonsync-tab-button moonsync-tab-active" : "moonsync-tab-button"
      });
      tabButton.addEventListener("click", () => {
        this.activeTab = tab.id;
        this.display();
      });
    });
    const configTab = containerEl.createDiv({ cls: this.activeTab === "configuration" ? "moonsync-tab-content moonsync-tab-visible" : "moonsync-tab-content moonsync-tab-hidden" });
    const contentTab = containerEl.createDiv({ cls: this.activeTab === "content" ? "moonsync-tab-content moonsync-tab-visible" : "moonsync-tab-content moonsync-tab-hidden" });
    const indexBaseTab = containerEl.createDiv({ cls: this.activeTab === "index-base" ? "moonsync-tab-content moonsync-tab-visible" : "moonsync-tab-content moonsync-tab-hidden" });
    const integrationsTab = containerEl.createDiv({ cls: this.activeTab === "integrations" ? "moonsync-tab-content moonsync-tab-visible" : "moonsync-tab-content moonsync-tab-hidden" });
    const aboutTab = containerEl.createDiv({ cls: this.activeTab === "about" ? "moonsync-tab-content moonsync-tab-visible" : "moonsync-tab-content moonsync-tab-hidden" });
    this.displayConfigurationTab(configTab);
    this.displayContentTab(contentTab);
    this.displayIndexBaseTab(indexBaseTab);
    this.displayIntegrationsTab(integrationsTab);
    this.displayAboutTab(aboutTab);
  }
  displayConfigurationTab(container) {
    new import_obsidian2.Setting(container).setName("Configuration").setDesc("Set up your Moon Reader backup location and note output folder.").setHeading();
    let textComponent;
    let validationEl;
    const pathSetting = new import_obsidian2.Setting(container).setName("Moon Reader sync path").setDesc(
      "Path to the folder containing your Moon Reader data. The .Moon+ folder will be detected automatically."
    ).addText((text) => {
      textComponent = text;
      text.setPlaceholder("/path/to/sync/folder").setValue(this.plugin.settings.syncPath).onChange(async (value) => {
        this.plugin.settings.syncPath = value;
        await this.plugin.saveSettings();
        this.validateSyncPath(value, validationEl);
      });
    }).addButton(
      (button) => button.setButtonText("Browse").onClick(async () => {
        const folder = await this.openFolderPicker();
        if (folder) {
          this.plugin.settings.syncPath = folder;
          textComponent.setValue(folder);
          await this.plugin.saveSettings();
          this.validateSyncPath(folder, validationEl);
        }
      })
    );
    validationEl = pathSetting.descEl.createDiv({ cls: "moonsync-path-validation" });
    if (this.plugin.settings.syncPath) {
      this.validateSyncPath(this.plugin.settings.syncPath, validationEl);
    }
    new import_obsidian2.Setting(container).setName("Output folder").setDesc("Folder in your vault where book notes will be created").addText(
      (text) => text.setPlaceholder("Books").setValue(this.plugin.settings.outputFolder).onChange(async (value) => {
        this.plugin.settings.outputFolder = value || "Books";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(container).setName("Sync").setDesc("Control when and how MoonSync syncs your highlights.").setHeading();
    new import_obsidian2.Setting(container).setName("Sync now").setDesc("Manually trigger a sync from Moon Reader").addButton(
      (button) => button.setButtonText("Sync").onClick(async () => {
        await this.plugin.runSync();
      })
    );
    new import_obsidian2.Setting(container).setName("Force reprocess all books").setDesc("Clears the metadata cache so all books are fully reprocessed on the next sync").addButton(
      (button) => button.setButtonText("Clear cache").onClick(async () => {
        const outputPath = (0, import_obsidian2.normalizePath)(this.plugin.settings.outputFolder);
        const cachePath = (0, import_obsidian2.normalizePath)(`${outputPath}/.moonsync-cache.json`);
        try {
          if (await this.app.vault.adapter.exists(cachePath)) {
            await this.app.vault.adapter.remove(cachePath);
          }
          new import_obsidian2.Notice("MoonSync: Cache cleared \u2014 next sync will reprocess all books");
        } catch (e) {
          new import_obsidian2.Notice("MoonSync: Failed to clear cache");
        }
      })
    );
    new import_obsidian2.Setting(container).setName("Sync on startup").setDesc("Automatically sync when Obsidian starts").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.syncOnStartup).onChange(async (value) => {
        this.plugin.settings.syncOnStartup = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(container).setName("Watch for changes").setDesc("Automatically sync when Moon Reader cache files are updated").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.watchForChanges).onChange(async (value) => {
        this.plugin.settings.watchForChanges = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.startFileWatcher();
        } else {
          this.plugin.stopFileWatcher();
        }
      })
    );
    new import_obsidian2.Setting(container).setName("Show ribbon icon").setDesc("Show sync button in ribbon menu").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showRibbonIcon).onChange(async (value) => {
        this.plugin.settings.showRibbonIcon = value;
        await this.plugin.saveSettings();
        this.plugin.updateRibbonIcon();
      })
    );
    new import_obsidian2.Setting(container).setName("Track books without highlights").setDesc("Track books you have started reading but have no existing highlights or notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.trackBooksWithoutHighlights).onChange(async (value) => {
        this.plugin.settings.trackBooksWithoutHighlights = value;
        await this.plugin.saveSettings();
      })
    );
  }
  displayContentTab(container) {
    new import_obsidian2.Setting(container).setName("Note content").setDesc("Control what data is included in your book notes.").setHeading();
    new import_obsidian2.Setting(container).setName("Show description").setDesc("Include book description in generated notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showDescription).onChange(async (value) => {
        this.plugin.settings.showDescription = value;
        await this.plugin.saveSettings();
        this.plugin.updateContentVisibility();
      })
    );
    new import_obsidian2.Setting(container).setName("Show reading progress").setDesc("Include reading progress section. Note: Progress data may not always be accurate depending on Moon Reader sync.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showReadingProgress).onChange(async (value) => {
        this.plugin.settings.showReadingProgress = value;
        await this.plugin.saveSettings();
        this.plugin.updateContentVisibility();
      })
    );
    new import_obsidian2.Setting(container).setName("Show highlight colors").setDesc("Use different callout styles based on highlight color. When off, all highlights appear as quotes.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showHighlightColors).onChange(async (value) => {
        this.plugin.settings.showHighlightColors = value;
        await this.plugin.saveSettings();
        this.plugin.updateContentVisibility();
      })
    );
    new import_obsidian2.Setting(container).setName("Show book covers").setDesc("Display book covers in notes. Covers are always downloaded to the 'covers' subfolder.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showCovers).onChange(async (value) => {
        this.plugin.settings.showCovers = value;
        await this.plugin.saveSettings();
        this.plugin.updateContentVisibility();
      })
    );
  }
  displayIndexBaseTab(container) {
    new import_obsidian2.Setting(container).setName("Library index").setDesc("Configure the automatically generated index of all your books.").setHeading();
    new import_obsidian2.Setting(container).setName("Generate library index").setDesc("Create an index note with summary stats and links to all books. Turning this off will delete the existing index note.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showIndex).onChange(async (value) => {
        this.plugin.settings.showIndex = value;
        await this.plugin.saveSettings();
        if (value) {
          await this.plugin.refreshIndex();
        } else {
          await this.plugin.deleteIndex();
        }
      })
    );
    new import_obsidian2.Setting(container).setName("Index note title").setDesc("Name of the library index note. Changing this will rename the existing file.").addText(
      (text) => text.setPlaceholder("1. Library Index").setValue(this.plugin.settings.indexNoteTitle).onChange(async (value) => {
        const oldName = this.plugin.settings.indexNoteTitle;
        const newName = value || "1. Library Index";
        if (oldName !== newName) {
          if (this.plugin.settings.showIndex) {
            await this.plugin.renameIndex(oldName, newName);
          }
          this.plugin.settings.indexNoteTitle = newName;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(container).setName("Show cover collage").setDesc("Display book covers at the top of the library index").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showCoverCollage).onChange(async (value) => {
        this.plugin.settings.showCoverCollage = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshIndex();
      })
    );
    new import_obsidian2.Setting(container).setName("Cover collage limit").setDesc("Maximum number of covers to show (0 = show all)").addText(
      (text) => text.setPlaceholder("0").setValue(String(this.plugin.settings.coverCollageLimit)).onChange(async (value) => {
        const num = parseInt(value) || 0;
        this.plugin.settings.coverCollageLimit = Math.max(0, num);
        await this.plugin.saveSettings();
        await this.plugin.refreshIndex();
      })
    );
    new import_obsidian2.Setting(container).setName("Cover collage sort").setDesc("How to sort covers in the collage").addDropdown(
      (dropdown) => dropdown.addOption("alpha", "Alphabetical").addOption("recent", "Most recent").setValue(this.plugin.settings.coverCollageSort).onChange(async (value) => {
        this.plugin.settings.coverCollageSort = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshIndex();
      })
    );
    new import_obsidian2.Setting(container).setName("Obsidian Bases").setDesc("Automatically generate a database configuration file for the Obsidian Bases plugin.").setHeading();
    new import_obsidian2.Setting(container).setName("Generate base file").setDesc("Automatically create and update the .base file for the Obsidian Bases plugin. Turning this off will delete the existing base file.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.generateBaseFile).onChange(async (value) => {
        this.plugin.settings.generateBaseFile = value;
        await this.plugin.saveSettings();
        if (value) {
          await this.plugin.refreshBase();
        } else {
          await this.plugin.deleteBase();
        }
      })
    );
    new import_obsidian2.Setting(container).setName("Base file name").setDesc("Name of the .base file (without extension). Changing this will rename the existing file.").addText(
      (text) => text.setPlaceholder("2. Books Database").setValue(this.plugin.settings.baseFileName).onChange(async (value) => {
        const oldName = this.plugin.settings.baseFileName;
        const newName = value || "2. Books Database";
        if (oldName !== newName) {
          if (this.plugin.settings.generateBaseFile) {
            await this.plugin.renameBase(oldName, newName);
          }
          this.plugin.settings.baseFileName = newName;
          await this.plugin.saveSettings();
        }
      })
    );
  }
  displayIntegrationsTab(container) {
    new import_obsidian2.Setting(container).setName("Hardcover.app").setDesc("Sync your reading status and progress to Hardcover.").setHeading();
    new import_obsidian2.Setting(container).setName("Enable Hardcover sync").setDesc("Update reading status on Hardcover after each sync").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.hardcoverEnabled).onChange(async (value) => {
        this.plugin.settings.hardcoverEnabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.hardcoverEnabled) {
      let tokenValidationEl;
      const tokenSetting = new import_obsidian2.Setting(container).setName("API token").setDesc("Your Hardcover bearer token from hardcover.app/account/api").addText(
        (text) => text.setPlaceholder("Enter your API token").setValue(this.plugin.settings.hardcoverToken).onChange(async (value) => {
          this.plugin.settings.hardcoverToken = value.trim();
          await this.plugin.saveSettings();
        })
      );
      tokenValidationEl = tokenSetting.descEl.createDiv({
        cls: "moonsync-path-validation"
      });
      new import_obsidian2.Setting(container).setName("Test connection").setDesc("Verify your API token is working").addButton(
        (button) => button.setButtonText("Test").onClick(async () => {
          if (!this.plugin.settings.hardcoverToken) {
            tokenValidationEl.empty();
            tokenValidationEl.createSpan({
              text: "Please enter a token first",
              attr: { style: "color: var(--text-warning); font-size: 0.85em; margin-top: 0.5em; display: block;" }
            });
            return;
          }
          button.setDisabled(true);
          button.setButtonText("Testing...");
          const { validateHardcoverToken: validateHardcoverToken2 } = await Promise.resolve().then(() => (init_hardcover(), hardcover_exports));
          const valid = await validateHardcoverToken2(this.plugin.settings.hardcoverToken);
          tokenValidationEl.empty();
          if (valid) {
            tokenValidationEl.createSpan({
              text: "\u2713 Connected to Hardcover",
              attr: { style: "color: var(--text-success); font-size: 0.85em; margin-top: 0.5em; display: block;" }
            });
          } else {
            tokenValidationEl.createSpan({
              text: "\u2717 Connection failed. Check your token.",
              attr: { style: "color: var(--text-error); font-size: 0.85em; margin-top: 0.5em; display: block;" }
            });
          }
          button.setDisabled(false);
          button.setButtonText("Test");
        })
      );
      new import_obsidian2.Setting(container).setDesc("0% \u2192 Want to Read. 1\u201398% \u2192 Currently Reading. 99%+ \u2192 Read. No progress data \u2192 skipped.");
    }
  }
  displayAboutTab(container) {
    new import_obsidian2.Setting(container).setName("About").setHeading();
    new import_obsidian2.Setting(container).setName("Sync your Moon Reader highlights to Obsidian").setDesc("Book covers, descriptions, and metadata from Google Books/Open Library").addButton(
      (button) => button.setButtonText("GitHub").onClick(() => {
        window.open("https://github.com/titandrive/Obsidian-MoonSync");
      })
    );
    new import_obsidian2.Setting(container).setName("Support").setHeading();
    new import_obsidian2.Setting(container).setName("Buy me a coffee").setDesc("If you find this plugin useful, consider supporting its development!").addButton(
      (button) => button.setButtonText("Ko-fi").onClick(() => {
        window.open("https://ko-fi.com/titandrive");
      })
    );
  }
  validateSyncPath(path, validationEl) {
    validationEl.empty();
    if (!path) {
      return;
    }
    const cachePath = (0, import_path.join)(path, ".Moon+", "Cache");
    if ((0, import_fs.existsSync)(cachePath)) {
      validationEl.createSpan({
        text: "\u2713 Moon Reader sync folder found",
        attr: { style: "color: var(--text-success); font-size: 0.85em; margin-top: 0.5em; display: block;" }
      });
    } else {
      validationEl.createSpan({
        text: "\u26A0 .Moon+/Cache folder not found at this path",
        attr: { style: "color: var(--text-warning); font-size: 0.85em; margin-top: 0.5em; display: block;" }
      });
    }
  }
  async openFolderPicker() {
    return new Promise((resolve) => {
      if ((0, import_os.platform)() === "darwin") {
        const script = `osascript -e 'POSIX path of (choose folder with prompt "Select Moon Reader sync folder")'`;
        (0, import_child_process.exec)(script, (error, stdout) => {
          if (error) {
            resolve(null);
          } else {
            resolve(stdout.trim());
          }
        });
      } else if ((0, import_os.platform)() === "win32") {
        const script = `powershell -command "Add-Type -AssemblyName System.Windows.Forms; $f = New-Object System.Windows.Forms.FolderBrowserDialog; $f.ShowDialog() | Out-Null; $f.SelectedPath"`;
        (0, import_child_process.exec)(script, (error, stdout) => {
          if (error) {
            resolve(null);
          } else {
            resolve(stdout.trim());
          }
        });
      } else {
        (0, import_child_process.exec)(
          'zenity --file-selection --directory --title="Select Moon Reader folder"',
          (error, stdout) => {
            if (error) {
              resolve(null);
            } else {
              resolve(stdout.trim());
            }
          }
        );
      }
    });
  }
};

// src/sync.ts
var import_obsidian7 = require("obsidian");

// src/modal.ts
var import_obsidian4 = require("obsidian");

// src/covers.ts
var import_obsidian3 = require("obsidian");
function pickBestTitleMatch(items, targetTitle, getTitle) {
  if (items.length === 1)
    return items[0];
  const target = targetTitle.toLowerCase().trim();
  let bestItem = items[0];
  let bestScore = -1;
  for (const item of items) {
    const candidate = getTitle(item).toLowerCase().trim();
    if (candidate === target)
      return item;
    const targetWords = target.split(/\s+/);
    const candidateWords = candidate.split(/\s+/);
    const commonWords = targetWords.filter((w) => candidateWords.includes(w)).length;
    const score = commonWords / Math.max(targetWords.length, candidateWords.length);
    if (score > bestScore) {
      bestScore = score;
      bestItem = item;
    }
  }
  return bestItem;
}
async function fetchBookInfo(title, author) {
  const cleanTitle = title.replace(/-{2,}/g, " ").replace(/[^a-zA-Z0-9\s\u00C0-\u024F'-]/g, " ").replace(/\s+/g, " ").trim();
  const cleanAuthor = author.replace(/-{2,}/g, " ").replace(/[^a-zA-Z0-9\s\u00C0-\u024F'-]/g, " ").replace(/\s+/g, " ").trim();
  const [openLibraryResult, googleBooksResult] = await Promise.all([
    fetchFromOpenLibrary(cleanTitle, cleanAuthor),
    fetchFromGoogleBooks(cleanTitle, cleanAuthor)
  ]);
  const coverUrl = openLibraryResult.coverUrl || googleBooksResult.coverUrl;
  const description = googleBooksResult.description || openLibraryResult.description;
  const fetchedTitle = googleBooksResult.title || openLibraryResult.title;
  const fetchedAuthor = googleBooksResult.author || openLibraryResult.author;
  const publishedDate = googleBooksResult.publishedDate || openLibraryResult.publishedDate;
  const publisher = googleBooksResult.publisher || openLibraryResult.publisher;
  const pageCount = googleBooksResult.pageCount || openLibraryResult.pageCount;
  const language = googleBooksResult.language || openLibraryResult.language;
  const genres = [];
  if (googleBooksResult.genres) {
    genres.push(...googleBooksResult.genres);
  }
  if (openLibraryResult.genres) {
    for (const genre of openLibraryResult.genres) {
      if (!genres.some((g) => g.toLowerCase() === genre.toLowerCase())) {
        genres.push(genre);
      }
    }
  }
  const series = openLibraryResult.series;
  let source = null;
  if (coverUrl || description) {
    source = googleBooksResult.description ? "googlebooks" : "openlibrary";
  }
  return {
    title: fetchedTitle,
    coverUrl,
    description,
    author: fetchedAuthor,
    source,
    publishedDate,
    publisher,
    pageCount,
    genres: genres.length > 0 ? genres : null,
    series,
    language
  };
}
async function batchFetchBookInfo(books, concurrency = 5) {
  const results = /* @__PURE__ */ new Map();
  for (let i = 0; i < books.length; i += concurrency) {
    const chunk = books.slice(i, i + concurrency);
    const chunkResults = await Promise.all(
      chunk.map(async (book) => {
        const key = `${book.title}|${book.author}`;
        try {
          const info = await fetchBookInfo(book.title, book.author);
          return { key, info };
        } catch (error) {
          console.debug(`MoonSync: Failed to fetch info for "${book.title}"`, error);
          return { key, info: null };
        }
      })
    );
    for (const { key, info } of chunkResults) {
      if (info) {
        results.set(key, info);
      }
    }
  }
  return results;
}
async function fetchFromOpenLibrary(title, author) {
  const result = {
    title: null,
    coverUrl: null,
    description: null,
    author: null,
    publishedDate: null,
    publisher: null,
    pageCount: null,
    genres: null,
    series: null,
    language: null
  };
  try {
    const query = encodeURIComponent(`${title} ${author}`);
    const searchUrl = `https://openlibrary.org/search.json?q=${query}&limit=5`;
    const response = await (0, import_obsidian3.requestUrl)({ url: searchUrl });
    const data = response.json;
    if (data.docs && data.docs.length > 0) {
      const book = pickBestTitleMatch(data.docs, title, (d) => d.title || "");
      if (book.title) {
        result.title = book.title;
      }
      if (book.cover_i) {
        result.coverUrl = `https://covers.openlibrary.org/b/id/${book.cover_i}-L.jpg`;
      } else if (book.isbn && book.isbn.length > 0) {
        result.coverUrl = `https://covers.openlibrary.org/b/isbn/${book.isbn[0]}-L.jpg`;
      }
      if (book.author_name && book.author_name.length > 0) {
        result.author = book.author_name[0];
      }
      if (book.first_publish_year) {
        result.publishedDate = book.first_publish_year.toString();
      }
      if (book.publisher && book.publisher.length > 0) {
        result.publisher = book.publisher[0];
      }
      if (book.number_of_pages_median) {
        result.pageCount = book.number_of_pages_median;
      }
      if (book.subject && book.subject.length > 0) {
        result.genres = book.subject.slice(0, 5);
      }
      if (book.language && book.language.length > 0) {
        result.language = book.language[0];
      }
      if (book.key) {
        try {
          const workUrl = `https://openlibrary.org${book.key}.json`;
          const workResponse = await (0, import_obsidian3.requestUrl)({ url: workUrl });
          const workData = workResponse.json;
          if (workData.description) {
            result.description = typeof workData.description === "string" ? workData.description : workData.description.value || null;
          }
          if (workData.series && workData.series.length > 0) {
            result.series = workData.series[0];
          }
        } catch (e) {
        }
      }
    }
  } catch (error) {
    console.debug("MoonSync: Open Library search failed", error);
  }
  return result;
}
async function fetchFromGoogleBooks(title, author) {
  var _a;
  const result = {
    title: null,
    coverUrl: null,
    description: null,
    author: null,
    publishedDate: null,
    publisher: null,
    pageCount: null,
    genres: null,
    language: null
  };
  try {
    const query = author ? `${title} ${author}` : title;
    const searchUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=5`;
    const response = await (0, import_obsidian3.requestUrl)({ url: searchUrl });
    const data = response.json;
    if (data.items && data.items.length > 0) {
      const book = pickBestTitleMatch(data.items, title, (item) => {
        var _a2;
        return ((_a2 = item.volumeInfo) == null ? void 0 : _a2.title) || "";
      });
      const volumeInfo = book.volumeInfo;
      if (volumeInfo == null ? void 0 : volumeInfo.title) {
        result.title = volumeInfo.title;
      }
      const imageLinks = volumeInfo == null ? void 0 : volumeInfo.imageLinks;
      if (imageLinks) {
        result.coverUrl = (_a = imageLinks.large || imageLinks.medium || imageLinks.thumbnail || imageLinks.smallThumbnail) == null ? void 0 : _a.replace("http://", "https://");
      }
      if (volumeInfo == null ? void 0 : volumeInfo.description) {
        result.description = volumeInfo.description;
      }
      if ((volumeInfo == null ? void 0 : volumeInfo.authors) && volumeInfo.authors.length > 0) {
        result.author = volumeInfo.authors[0];
      }
      if (volumeInfo == null ? void 0 : volumeInfo.publishedDate) {
        result.publishedDate = volumeInfo.publishedDate;
      }
      if (volumeInfo == null ? void 0 : volumeInfo.publisher) {
        result.publisher = volumeInfo.publisher;
      }
      if (volumeInfo == null ? void 0 : volumeInfo.pageCount) {
        result.pageCount = volumeInfo.pageCount;
      }
      if ((volumeInfo == null ? void 0 : volumeInfo.categories) && volumeInfo.categories.length > 0) {
        result.genres = volumeInfo.categories;
      }
      if (volumeInfo == null ? void 0 : volumeInfo.language) {
        result.language = volumeInfo.language;
      }
    }
  } catch (error) {
    console.debug("MoonSync: Google Books search failed", error);
  }
  return result;
}
async function fetchMultipleBookCovers(title, author, maxResults = 10) {
  var _a, _b, _c, _d, _e, _f, _g;
  const results = [];
  try {
    const googleQuery = author ? `${title} ${author}` : title;
    const googleUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(googleQuery)}&maxResults=${maxResults}`;
    const googleResponse = await (0, import_obsidian3.requestUrl)({ url: googleUrl });
    const googleData = googleResponse.json;
    if (googleData.items && googleData.items.length > 0) {
      for (const book of googleData.items) {
        const volumeInfo = book.volumeInfo;
        const imageLinks = volumeInfo == null ? void 0 : volumeInfo.imageLinks;
        if (imageLinks) {
          const coverUrl = (_a = imageLinks.large || imageLinks.medium || imageLinks.thumbnail || imageLinks.smallThumbnail) == null ? void 0 : _a.replace("http://", "https://");
          if (coverUrl) {
            results.push({
              title: (volumeInfo == null ? void 0 : volumeInfo.title) || null,
              author: ((_b = volumeInfo == null ? void 0 : volumeInfo.authors) == null ? void 0 : _b[0]) || null,
              coverUrl,
              description: (volumeInfo == null ? void 0 : volumeInfo.description) || null,
              source: "googlebooks",
              publishedDate: (volumeInfo == null ? void 0 : volumeInfo.publishedDate) || null,
              publisher: (volumeInfo == null ? void 0 : volumeInfo.publisher) || null,
              pageCount: (volumeInfo == null ? void 0 : volumeInfo.pageCount) || null,
              genres: (volumeInfo == null ? void 0 : volumeInfo.categories) || null,
              series: null,
              language: (volumeInfo == null ? void 0 : volumeInfo.language) || null
            });
          }
        }
      }
    }
  } catch (error) {
    console.debug("MoonSync: Google Books search failed", error);
  }
  try {
    const olQuery = encodeURIComponent(`${title} ${author}`);
    const olUrl = `https://openlibrary.org/search.json?q=${olQuery}&limit=${maxResults}`;
    const olResponse = await (0, import_obsidian3.requestUrl)({ url: olUrl });
    const olData = olResponse.json;
    if (olData.docs && olData.docs.length > 0) {
      for (const book of olData.docs) {
        let coverUrl = null;
        if (book.cover_i) {
          coverUrl = `https://covers.openlibrary.org/b/id/${book.cover_i}-L.jpg`;
        } else if (book.isbn && book.isbn.length > 0) {
          coverUrl = `https://covers.openlibrary.org/b/isbn/${book.isbn[0]}-L.jpg`;
        }
        if (coverUrl) {
          results.push({
            title: book.title || null,
            author: ((_c = book.author_name) == null ? void 0 : _c[0]) || null,
            coverUrl,
            description: null,
            // Would need extra API call per book
            source: "openlibrary",
            publishedDate: ((_d = book.first_publish_year) == null ? void 0 : _d.toString()) || null,
            publisher: ((_e = book.publisher) == null ? void 0 : _e[0]) || null,
            pageCount: book.number_of_pages_median || null,
            genres: ((_f = book.subject) == null ? void 0 : _f.slice(0, 5)) || null,
            series: null,
            language: ((_g = book.language) == null ? void 0 : _g[0]) || null
          });
        }
      }
    }
  } catch (error) {
    console.debug("MoonSync: Open Library search failed", error);
  }
  const uniqueResults = results.filter(
    (result, index, self2) => index === self2.findIndex((r) => r.coverUrl === result.coverUrl)
  );
  return uniqueResults;
}
async function downloadCover(url) {
  try {
    const response = await (0, import_obsidian3.requestUrl)({ url });
    return response.arrayBuffer;
  } catch (error) {
    console.debug("MoonSync: Failed to download cover", error);
    return null;
  }
}
async function downloadAndResizeCover(url, maxWidth = 400, maxHeight = 600) {
  try {
    const response = await (0, import_obsidian3.requestUrl)({ url });
    const arrayBuffer = response.arrayBuffer;
    const blob = new Blob([arrayBuffer]);
    const imageBitmap = await createImageBitmap(blob);
    let width = imageBitmap.width;
    let height = imageBitmap.height;
    if (width > maxWidth) {
      height = height * maxWidth / width;
      width = maxWidth;
    }
    if (height > maxHeight) {
      width = width * maxHeight / height;
      height = maxHeight;
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      console.debug("MoonSync: Failed to get canvas context");
      return arrayBuffer;
    }
    ctx.drawImage(imageBitmap, 0, 0, width, height);
    const resizedBlob = await new Promise((resolve) => {
      canvas.toBlob((blob2) => resolve(blob2), "image/jpeg", 0.85);
    });
    if (!resizedBlob) {
      return arrayBuffer;
    }
    return await resizedBlob.arrayBuffer();
  } catch (error) {
    console.debug("MoonSync: Failed to download/resize cover", error);
    return null;
  }
}

// src/modal.ts
var SyncSummaryModal = class extends import_obsidian4.Modal {
  constructor(app, result, settings) {
    super(app);
    this.result = result;
    this.settings = settings;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-summary-modal");
    const hasFailures = this.result.failedBooks && this.result.failedBooks.length > 0;
    const title = hasFailures ? "MoonSync import complete (with errors)" : "MoonSync import complete";
    contentEl.createEl("h2", { text: title });
    const statsContainer = contentEl.createDiv({ cls: "moonsync-stats" });
    this.createStatItem(statsContainer, this.result.booksCreated.toString(), "Books imported");
    this.createStatItem(statsContainer, this.result.booksCreated.toString(), "Notes created");
    this.createStatItem(statsContainer, this.result.totalHighlights.toString(), "Highlights");
    this.createStatItem(statsContainer, this.result.totalNotes.toString(), "Notes");
    if (hasFailures) {
      const failedSection = contentEl.createDiv({ cls: "moonsync-failed-section" });
      failedSection.createEl("h3", { text: `Failed (${this.result.failedBooks.length})` });
      const failedList = failedSection.createEl("ul", { cls: "moonsync-failed-list" });
      for (const failed of this.result.failedBooks) {
        const item = failedList.createEl("li");
        item.createSpan({ text: failed.title, cls: "moonsync-failed-title" });
        item.createSpan({ text: ` - ${failed.error}`, cls: "moonsync-failed-error" });
      }
    }
    const settingsLink = contentEl.createDiv({ cls: "moonsync-settings-link" });
    const link = settingsLink.createEl("a", { text: "Open MoonSync settings" });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      this.close();
      const app = this.app;
      app.setting.open();
      app.setting.openTabById("moonsync");
    });
    const buttonContainer = contentEl.createDiv({ cls: "moonsync-button-container" });
    const openIndexButton = buttonContainer.createEl("button", { text: "Open library" });
    openIndexButton.addEventListener("click", async () => {
      this.close();
      const indexPath = (0, import_obsidian4.normalizePath)(`${this.settings.outputFolder}/${this.settings.indexNoteTitle}.md`);
      const file = this.app.vault.getAbstractFileByPath(indexPath);
      if (file) {
        await this.app.workspace.openLinkText(indexPath, "", false);
      }
    });
    const closeButton = buttonContainer.createEl("button", { text: "Done" });
    closeButton.addEventListener("click", () => this.close());
  }
  createStatItem(container, value, label) {
    const item = container.createDiv({ cls: "moonsync-stat-item" });
    item.createDiv({ cls: "moonsync-stat-value", text: value });
    item.createDiv({ cls: "moonsync-stat-label", text: label });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SelectCoverModal = class extends import_obsidian4.Modal {
  constructor(app, title, author, onSelect) {
    super(app);
    this.customUrl = "";
    this.resultsContainer = null;
    this.title = title;
    this.author = author;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-select-cover-modal");
    modalEl.addClass("mod-moonsync-cover");
    new import_obsidian4.Setting(contentEl).setName("Fetch book cover").setHeading();
    const tabNav = contentEl.createDiv({ cls: "moonsync-tab-nav" });
    const searchTab = tabNav.createEl("button", { text: "Search", cls: "moonsync-tab active" });
    const urlTab = tabNav.createEl("button", { text: "Import", cls: "moonsync-tab" });
    const searchContent = contentEl.createDiv({ cls: "moonsync-tab-content active" });
    const urlContent = contentEl.createDiv({ cls: "moonsync-tab-content" });
    searchTab.addEventListener("click", () => {
      searchTab.addClass("active");
      urlTab.removeClass("active");
      searchContent.addClass("active");
      urlContent.removeClass("active");
    });
    urlTab.addEventListener("click", () => {
      urlTab.addClass("active");
      searchTab.removeClass("active");
      urlContent.addClass("active");
      searchContent.removeClass("active");
    });
    const titleSetting = new import_obsidian4.Setting(searchContent).setName("Title").addText((text) => {
      text.setPlaceholder("Enter book title").setValue(this.title).onChange((value) => {
        this.title = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          void this.performSearch();
        }
      });
    });
    titleSetting.settingEl.addClass("moonsync-labeled-field");
    const authorSetting = new import_obsidian4.Setting(searchContent).setName("Author").addText((text) => {
      text.setPlaceholder("Enter author name").setValue(this.author).onChange((value) => {
        this.author = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          void this.performSearch();
        }
      });
    });
    authorSetting.settingEl.addClass("moonsync-labeled-field");
    new import_obsidian4.Setting(searchContent).addButton((button) => {
      button.setButtonText("Search").setCta().onClick(() => this.performSearch());
    });
    this.resultsContainer = searchContent.createDiv({ cls: "moonsync-cover-results" });
    urlContent.createEl("p", {
      text: "If search can't find the cover, or you have one you prefer, you can import it here.",
      cls: "moonsync-url-description"
    });
    const urlSetting = new import_obsidian4.Setting(urlContent).setName("URL").addText((text) => {
      text.setPlaceholder("https://example.com/cover.jpg").onChange((value) => {
        this.customUrl = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          if (this.customUrl.trim()) {
            this.onSelect(this.customUrl.trim());
            this.close();
          }
        }
      });
    });
    urlSetting.settingEl.addClass("moonsync-labeled-field");
    new import_obsidian4.Setting(urlContent).addButton((button) => {
      button.setButtonText("Import").setCta().onClick(() => {
        if (this.customUrl.trim()) {
          this.onSelect(this.customUrl.trim());
          this.close();
        }
      });
    });
    setTimeout(() => {
      void this.performSearch();
    }, 150);
  }
  async performSearch() {
    if (!this.resultsContainer)
      return;
    this.resultsContainer.empty();
    if (!this.title.trim()) {
      this.resultsContainer.createEl("p", {
        text: "Please enter a book title.",
        cls: "setting-item-description"
      });
      return;
    }
    const loadingEl = this.resultsContainer.createDiv({ cls: "moonsync-loading" });
    loadingEl.setText("Searching for covers...");
    const covers = await fetchMultipleBookCovers(this.title, this.author, 10);
    loadingEl.remove();
    if (covers.length === 0) {
      this.resultsContainer.createEl("p", {
        text: "No covers found. Try a different search query.",
        cls: "setting-item-description"
      });
      return;
    }
    this.resultsContainer.createEl("p", {
      text: `Found ${covers.length} result${covers.length === 1 ? "" : "s"} for "${this.title}"${this.author ? ` by ${this.author}` : ""}`,
      cls: "moonsync-search-info"
    });
    const gridContainer = this.resultsContainer.createDiv({ cls: "moonsync-cover-grid" });
    for (const cover of covers) {
      const coverItem = gridContainer.createDiv({ cls: "moonsync-cover-item" });
      coverItem.createEl("img", {
        attr: {
          src: cover.coverUrl || "",
          alt: cover.title || "Book cover"
        }
      });
      const info = coverItem.createDiv({ cls: "moonsync-cover-info" });
      if (cover.title) {
        info.createDiv({ cls: "moonsync-cover-title", text: cover.title });
      }
      if (cover.author) {
        info.createDiv({ cls: "moonsync-cover-author", text: cover.author });
      }
      if (cover.publishedDate) {
        info.createDiv({ cls: "moonsync-cover-year", text: cover.publishedDate });
      }
      coverItem.addEventListener("click", () => {
        if (cover.coverUrl) {
          this.onSelect(cover.coverUrl);
          this.close();
        }
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SelectBookMetadataModal = class extends import_obsidian4.Modal {
  constructor(app, title, author, onSelect) {
    super(app);
    this.resultsContainer = null;
    this.title = title;
    this.author = author;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-select-cover-modal");
    modalEl.addClass("mod-moonsync-cover");
    new import_obsidian4.Setting(contentEl).setName("Fetch book metadata").setHeading();
    contentEl.createEl("p", {
      text: "Select a book to replace all metadata including cover, description, and details.",
      cls: "moonsync-url-description"
    });
    const titleSetting = new import_obsidian4.Setting(contentEl).setName("Title").addText((text) => {
      text.setPlaceholder("Enter book title").setValue(this.title).onChange((value) => {
        this.title = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          void this.performSearch();
        }
      });
    });
    titleSetting.settingEl.addClass("moonsync-labeled-field");
    const authorSetting = new import_obsidian4.Setting(contentEl).setName("Author").addText((text) => {
      text.setPlaceholder("Enter author name").setValue(this.author).onChange((value) => {
        this.author = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          void this.performSearch();
        }
      });
    });
    authorSetting.settingEl.addClass("moonsync-labeled-field");
    new import_obsidian4.Setting(contentEl).addButton((button) => {
      button.setButtonText("Search").setCta().onClick(() => this.performSearch());
    });
    this.resultsContainer = contentEl.createDiv({ cls: "moonsync-cover-results" });
    setTimeout(() => {
      void this.performSearch();
    }, 150);
  }
  async performSearch() {
    if (!this.resultsContainer)
      return;
    this.resultsContainer.empty();
    if (!this.title.trim()) {
      this.resultsContainer.createEl("p", {
        text: "Please enter a book title.",
        cls: "setting-item-description"
      });
      return;
    }
    const loadingEl = this.resultsContainer.createDiv({ cls: "moonsync-loading" });
    loadingEl.setText("Searching for books...");
    const books = await fetchMultipleBookCovers(this.title, this.author, 10);
    loadingEl.remove();
    if (books.length === 0) {
      this.resultsContainer.createEl("p", {
        text: "No books found. Try a different search query.",
        cls: "setting-item-description"
      });
      return;
    }
    this.resultsContainer.createEl("p", {
      text: `Found ${books.length} result${books.length === 1 ? "" : "s"} for "${this.title}"${this.author ? ` by ${this.author}` : ""}`,
      cls: "moonsync-search-info"
    });
    const gridContainer = this.resultsContainer.createDiv({ cls: "moonsync-cover-grid" });
    for (const book of books) {
      const bookItem = gridContainer.createDiv({ cls: "moonsync-cover-item" });
      if (book.coverUrl) {
        bookItem.createEl("img", {
          attr: {
            src: book.coverUrl,
            alt: book.title || "Book cover"
          }
        });
      }
      const info = bookItem.createDiv({ cls: "moonsync-cover-info" });
      if (book.title) {
        info.createDiv({ cls: "moonsync-cover-title", text: book.title });
      }
      if (book.author) {
        info.createDiv({ cls: "moonsync-cover-author", text: book.author });
      }
      const details = [];
      if (book.publishedDate) {
        details.push(book.publishedDate);
      }
      if (book.publisher) {
        details.push(book.publisher);
      }
      if (book.pageCount) {
        details.push(`${book.pageCount} pages`);
      }
      if (details.length > 0) {
        info.createDiv({ cls: "moonsync-cover-year", text: details.join(" \xB7 ") });
      }
      bookItem.addEventListener("click", () => {
        this.onSelect(book);
        this.close();
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CreateBookModal = class extends import_obsidian4.Modal {
  constructor(app, settings, onSubmit) {
    super(app);
    this.title = "";
    this.author = "";
    this.resultsContainer = null;
    this.settings = settings;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-select-cover-modal");
    modalEl.addClass("mod-moonsync-cover");
    new import_obsidian4.Setting(contentEl).setName("Create book note").setHeading();
    contentEl.createEl("p", {
      text: "Search for a book and select it to create a note.",
      cls: "moonsync-url-description"
    });
    const titleSetting = new import_obsidian4.Setting(contentEl).setName("Title").addText((text) => {
      text.setPlaceholder("Enter book title").setValue(this.title).onChange((value) => {
        this.title = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          void this.performSearch();
        }
      });
    });
    titleSetting.settingEl.addClass("moonsync-labeled-field");
    const authorSetting = new import_obsidian4.Setting(contentEl).setName("Author").addText((text) => {
      text.setPlaceholder("Enter author name (optional)").setValue(this.author).onChange((value) => {
        this.author = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          void this.performSearch();
        }
      });
    });
    authorSetting.settingEl.addClass("moonsync-labeled-field");
    new import_obsidian4.Setting(contentEl).addButton((button) => {
      button.setButtonText("Search").setCta().onClick(() => this.performSearch());
    });
    this.resultsContainer = contentEl.createDiv({ cls: "moonsync-cover-results" });
  }
  async performSearch() {
    if (!this.resultsContainer)
      return;
    this.resultsContainer.empty();
    if (!this.title.trim()) {
      this.resultsContainer.createEl("p", {
        text: "Please enter a book title.",
        cls: "setting-item-description"
      });
      return;
    }
    const loadingEl = this.resultsContainer.createDiv({ cls: "moonsync-loading" });
    loadingEl.setText("Searching for books...");
    const books = await fetchMultipleBookCovers(this.title, this.author, 10);
    loadingEl.remove();
    if (books.length === 0) {
      this.resultsContainer.createEl("p", {
        text: "No books found. Try a different search query.",
        cls: "setting-item-description"
      });
      return;
    }
    this.resultsContainer.createEl("p", {
      text: `Found ${books.length} result${books.length === 1 ? "" : "s"} for "${this.title}"${this.author ? ` by ${this.author}` : ""}`,
      cls: "moonsync-search-info"
    });
    const gridContainer = this.resultsContainer.createDiv({ cls: "moonsync-cover-grid" });
    for (const book of books) {
      const bookItem = gridContainer.createDiv({ cls: "moonsync-cover-item" });
      if (book.coverUrl) {
        bookItem.createEl("img", {
          attr: {
            src: book.coverUrl,
            alt: book.title || "Book cover"
          }
        });
      }
      const info = bookItem.createDiv({ cls: "moonsync-cover-info" });
      if (book.title) {
        info.createDiv({ cls: "moonsync-cover-title", text: book.title });
      }
      if (book.author) {
        info.createDiv({ cls: "moonsync-cover-author", text: book.author });
      }
      const details = [];
      if (book.publishedDate) {
        details.push(book.publishedDate);
      }
      if (book.publisher) {
        details.push(book.publisher);
      }
      if (book.pageCount) {
        details.push(`${book.pageCount} pages`);
      }
      if (details.length > 0) {
        info.createDiv({ cls: "moonsync-cover-year", text: details.join(" \xB7 ") });
      }
      bookItem.addEventListener("click", () => {
        this.onSubmit(book);
        this.close();
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function generateBookTemplate(title, author, coverPath, description, publishedDate = null, publisher = null, pageCount = null, genres = null, series = null, language = null) {
  const lines = [];
  const escapeYaml3 = (str) => str.replace(/"/g, '\\"').replace(/\n/g, " ");
  lines.push("---");
  lines.push(`title: "${escapeYaml3(title)}"`);
  if (author) {
    lines.push(`author: "${escapeYaml3(author)}"`);
  }
  lines.push(`last_synced: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  lines.push("highlights_count: 0");
  lines.push("manual_note: true");
  if (publishedDate) {
    lines.push(`published_date: "${escapeYaml3(publishedDate)}"`);
  }
  if (publisher) {
    lines.push(`publisher: "${escapeYaml3(publisher)}"`);
  }
  if (pageCount !== null) {
    lines.push(`page_count: ${pageCount}`);
  }
  if (genres && genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of genres) {
      lines.push(`  - "${escapeYaml3(genre)}"`);
    }
  }
  if (series) {
    lines.push(`series: "${escapeYaml3(series)}"`);
  }
  if (language) {
    lines.push(`language: "${language}"`);
  }
  if (coverPath) {
    lines.push(`cover: "${coverPath}"`);
  }
  lines.push("---");
  lines.push(`# ${title}`);
  if (author) {
    lines.push(`**Author:** ${author}`);
  }
  lines.push("");
  if (coverPath) {
    lines.push(`![[${coverPath}|200]]`);
    lines.push("");
  }
  if (description) {
    lines.push("## Description");
    lines.push(description);
    lines.push("");
  }
  lines.push("## Highlights");
  lines.push("");
  lines.push("> [!quote]");
  lines.push("> Add your highlights here...");
  lines.push("");
  return lines.join("\n");
}
var UpdateHardcoverModal = class extends import_obsidian4.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: "Update Hardcover link" });
    contentEl.createEl("p", {
      text: "Paste the Hardcover URL for this book to correct the match.",
      cls: "setting-item-description"
    });
    let url = "";
    new import_obsidian4.Setting(contentEl).setName("Hardcover URL").addText((text) => {
      text.setPlaceholder("https://hardcover.app/books/...");
      text.onChange((value) => {
        url = value;
      });
      text.inputEl.style.width = "100%";
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          if (url.trim()) {
            this.onSubmit(url.trim());
            this.close();
          }
        }
      });
    });
    new import_obsidian4.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Update").setCta().onClick(() => {
        if (url.trim()) {
          this.onSubmit(url.trim());
          this.close();
        }
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/parser/annotations.ts
var import_promises = require("fs/promises");
var import_path2 = require("path");
var import_zlib = require("zlib");
function normalizeBookTitle(title) {
  return title.replace(/\.(epub|mobi|pdf|azw3?|fb2|txt)$/i, "").trim();
}
function parseAnnotationFile(data, filename) {
  try {
    const decompressed = (0, import_zlib.inflateSync)(data).toString("utf-8");
    const lines = decompressed.split("\n");
    const baseName = filename.replace(/\.(epub|mobi|pdf|azw3?|fb2|txt)\.an$/i, "");
    const bookTitle = normalizeBookTitle(baseName);
    const highlights = [];
    let i = 0;
    while (i < lines.length && lines[i] !== "#") {
      i++;
    }
    while (i < lines.length) {
      if (lines[i] === "#") {
        i++;
        if (i >= lines.length)
          break;
        const id = parseInt(lines[i++] || "0", 10);
        const title = lines[i++] || "";
        const fullPath = lines[i++] || "";
        i++;
        const chapter = parseInt(lines[i++] || "0", 10);
        i++;
        const position = parseInt(lines[i++] || "0", 10);
        const length = parseInt(lines[i++] || "0", 10);
        const color = parseInt(lines[i++] || "0", 10);
        const timestamp = parseInt(lines[i++] || "0", 10);
        while (i < lines.length && lines[i] === "") {
          i++;
        }
        let text = "";
        let note = "";
        if (i < lines.length && lines[i] !== "0") {
          const firstLine = lines[i].replace(/<BR>/g, "\n").trim();
          i++;
          if (i < lines.length && lines[i] !== "0" && lines[i] !== "") {
            note = firstLine;
            text = lines[i].replace(/<BR>/g, "\n").trim();
            i++;
          } else {
            text = firstLine;
          }
        }
        while (i < lines.length && (lines[i] === "0" || lines[i] === "")) {
          i++;
        }
        if (text) {
          highlights.push({
            id,
            book: normalizeBookTitle(title),
            filename: fullPath,
            chapter,
            position,
            highlightLength: length,
            highlightColor: color,
            timestamp,
            bookmark: "",
            note,
            originalText: text,
            underline: false,
            strikethrough: false
          });
        }
      } else {
        i++;
      }
    }
    return {
      filename,
      bookTitle,
      highlights
    };
  } catch (error) {
    console.debug(`MoonSync: Failed to parse annotation file ${filename}`, error);
    return null;
  }
}
function parseProgressFile(data) {
  try {
    const content = data.toString("utf-8").trim();
    const match = content.match(/^(\d+)\*(\d+)@\d+#\d+:(\d+(?:\.\d+)?)%$/);
    if (match) {
      return {
        timestamp: parseInt(match[1], 10),
        chapter: parseInt(match[2], 10),
        progress: parseFloat(match[3])
      };
    }
  } catch (e) {
  }
  return null;
}
function normalizeKey(title) {
  return title.toLowerCase().replace(/[^a-z0-9\s]/g, "").replace(/\s+/g, " ").trim();
}
async function parseAnnotationFiles(syncPath, trackBooksWithoutHighlights = false) {
  var _a;
  const cacheDir = (0, import_path2.join)(syncPath, ".Moon+", "Cache");
  const bookDataMap = /* @__PURE__ */ new Map();
  try {
    const files = await (0, import_promises.readdir)(cacheDir);
    const anFiles = files.filter((f) => f.endsWith(".an"));
    for (const anFile of anFiles) {
      try {
        const filePath = (0, import_path2.join)(cacheDir, anFile);
        const data = await (0, import_promises.readFile)(filePath);
        const parsed = parseAnnotationFile(data, anFile);
        if (parsed) {
          const actualTitle = (parsed.highlights.length > 0 ? (_a = parsed.highlights[0]) == null ? void 0 : _a.book : null) || parsed.bookTitle;
          const key = normalizeKey(actualTitle);
          if (!bookDataMap.has(key)) {
            const book = {
              id: 0,
              title: actualTitle,
              filename: anFile.replace(/\.an$/, ""),
              author: "",
              description: "",
              category: "",
              thumbFile: "",
              coverFile: "",
              addTime: "",
              favorite: ""
            };
            bookDataMap.set(key, {
              book,
              highlights: [],
              statistics: null,
              progress: null,
              currentChapter: null,
              lastReadTimestamp: null,
              coverPath: null,
              fetchedDescription: null,
              publishedDate: null,
              publisher: null,
              pageCount: null,
              genres: null,
              series: null,
              isbn10: null,
              isbn13: null,
              language: null,
              previousTitle: null
            });
          }
          if (parsed.highlights.length > 0) {
            const bookData = bookDataMap.get(key);
            bookData.highlights.push(...parsed.highlights);
          }
        }
      } catch (error) {
        console.debug(`MoonSync: Error reading ${anFile}`, error);
      }
    }
    const filenameToKey = /* @__PURE__ */ new Map();
    for (const [mapKey, bookData] of bookDataMap) {
      if (bookData.book.filename) {
        filenameToKey.set(bookData.book.filename.toLowerCase().normalize("NFC"), mapKey);
      }
    }
    const poFiles = files.filter((f) => f.endsWith(".po"));
    for (const poFile of poFiles) {
      try {
        const baseName = poFile.replace(/\.(epub|mobi|pdf|azw3?|fb2|txt)\.po$/i, "");
        let bookTitle = baseName;
        if (!bookTitle.includes(" ") && bookTitle.includes("_")) {
          bookTitle = bookTitle.replace(/_/g, " ");
        }
        const epubFilename = poFile.replace(/\.po$/, "").toLowerCase().normalize("NFC");
        const key = filenameToKey.get(epubFilename) || normalizeKey(bookTitle);
        const filePath = (0, import_path2.join)(cacheDir, poFile);
        const data = await (0, import_promises.readFile)(filePath);
        const progressData = parseProgressFile(data);
        const fileStat = await (0, import_promises.stat)(filePath);
        const fileMtime = fileStat.mtimeMs;
        if (bookDataMap.has(key)) {
          if (progressData !== null) {
            const bookData = bookDataMap.get(key);
            const existingTimestamp = bookData.lastReadTimestamp || 0;
            if (fileMtime > existingTimestamp || fileMtime === existingTimestamp && progressData.progress > (bookData.progress || 0)) {
              bookData.progress = progressData.progress;
              bookData.currentChapter = progressData.chapter;
              bookData.lastReadTimestamp = fileMtime;
            }
          }
        } else if (trackBooksWithoutHighlights && progressData !== null) {
          const book = {
            id: 0,
            title: bookTitle,
            filename: poFile.replace(/\.po$/, ""),
            author: "",
            description: "",
            category: "",
            thumbFile: "",
            coverFile: "",
            addTime: "",
            favorite: ""
          };
          bookDataMap.set(key, {
            book,
            highlights: [],
            statistics: null,
            progress: progressData.progress,
            currentChapter: progressData.chapter,
            lastReadTimestamp: fileMtime,
            coverPath: null,
            fetchedDescription: null,
            publishedDate: null,
            publisher: null,
            pageCount: null,
            genres: null,
            series: null,
            isbn10: null,
            isbn13: null,
            language: null
          });
        }
      } catch (error) {
        console.debug(`MoonSync: Error reading ${poFile}`, error);
      }
    }
    for (const bookData of bookDataMap.values()) {
      bookData.highlights.sort((a, b) => a.position - b.position);
    }
    return Array.from(bookDataMap.values());
  } catch (error) {
    console.debug("MoonSync: Failed to read Cache directory", error);
    return [];
  }
}

// src/utils.ts
function escapeYaml(str) {
  return str.replace(/"/g, '\\"').replace(/\n/g, " ");
}
function extractFrontmatter(content) {
  if (!content.startsWith("---")) {
    return null;
  }
  const endIndex = content.indexOf("---", 3);
  if (endIndex === -1) {
    return null;
  }
  return content.substring(3, endIndex);
}
function parseFrontmatterField(frontmatter, fieldName) {
  const regex = new RegExp(`^${fieldName}:\\s*"?([^"\\n]+)"?`, "m");
  const match = frontmatter.match(regex);
  return match ? match[1].trim() : null;
}
function parseFrontmatter(content) {
  const frontmatter = extractFrontmatter(content);
  if (!frontmatter) {
    return {
      title: null,
      author: null,
      progress: null,
      highlightsCount: null,
      highlightsHash: null,
      coverPath: null,
      moonReaderPath: null,
      lastRead: null,
      lastSynced: null,
      isManualNote: false,
      hasCustomMetadata: false
    };
  }
  const progressStr = parseFrontmatterField(frontmatter, "progress");
  const highlightsCountStr = parseFrontmatterField(frontmatter, "highlights_count");
  return {
    title: parseFrontmatterField(frontmatter, "title"),
    author: parseFrontmatterField(frontmatter, "author"),
    progress: progressStr ? parseFloat(progressStr) : null,
    highlightsCount: highlightsCountStr !== null ? parseInt(highlightsCountStr, 10) : null,
    highlightsHash: parseFrontmatterField(frontmatter, "highlights_hash"),
    coverPath: parseFrontmatterField(frontmatter, "cover"),
    moonReaderPath: parseFrontmatterField(frontmatter, "moon_reader_path"),
    lastRead: parseFrontmatterField(frontmatter, "last_read"),
    lastSynced: parseFrontmatterField(frontmatter, "last_synced"),
    isManualNote: /^manual_note:\s*true/m.test(frontmatter),
    hasCustomMetadata: /^custom_metadata:\s*true/m.test(frontmatter)
  };
}
function computeHighlightsHash(highlights) {
  if (highlights.length === 0)
    return "";
  const sorted = [...highlights].sort((a, b) => a.position - b.position);
  const fingerprint = sorted.map((h) => `${h.position}:${h.timestamp}:${h.originalText.length}`).join("|");
  let hash = 5381;
  for (let i = 0; i < fingerprint.length; i++) {
    hash = (hash << 5) + hash + fingerprint.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

// src/writer/markdown.ts
function generateBookNote(bookData, settings) {
  const { book, highlights, statistics, progress, currentChapter, lastReadTimestamp, coverPath, fetchedDescription, publishedDate, publisher, pageCount, genres, series, isbn10, isbn13, language } = bookData;
  const lines = [];
  lines.push("---");
  lines.push(`title: "${escapeYaml(book.title)}"`);
  if (book.author) {
    lines.push(`author: "${escapeYaml(book.author)}"`);
  }
  if (book.category) {
    const category = parseCategory(book.category);
    if (category) {
      lines.push(`category: "${escapeYaml(category)}"`);
    }
  }
  if (progress !== null) {
    lines.push(`progress: ${progress.toFixed(1)}%`);
  }
  if (currentChapter !== null) {
    lines.push(`current_chapter: ${currentChapter}`);
  }
  if (lastReadTimestamp !== null) {
    lines.push(`last_read: ${new Date(lastReadTimestamp).toISOString().split("T")[0]}`);
  }
  if (statistics == null ? void 0 : statistics.usedTime) {
    lines.push(`reading_time: "${formatDuration(statistics.usedTime)}"`);
  }
  lines.push(`last_synced: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  lines.push(`moon_reader_path: "${escapeYaml(book.filename)}"`);
  lines.push(`highlights_count: ${highlights.length}`);
  lines.push(`highlights_hash: "${computeHighlightsHash(highlights)}"`);
  const notesCount = highlights.filter((h) => h.note && h.note.trim()).length;
  lines.push(`notes_count: ${notesCount}`);
  if (publishedDate) {
    lines.push(`published_date: "${escapeYaml(publishedDate)}"`);
  }
  if (publisher) {
    lines.push(`publisher: "${escapeYaml(publisher)}"`);
  }
  if (pageCount !== null) {
    lines.push(`page_count: ${pageCount}`);
  }
  if (genres && genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of genres) {
      lines.push(`  - "${escapeYaml(genre)}"`);
    }
  }
  if (series) {
    lines.push(`series: "${escapeYaml(series)}"`);
  }
  if (isbn10) {
    lines.push(`isbn_10: "${isbn10}"`);
  }
  if (isbn13) {
    lines.push(`isbn_13: "${isbn13}"`);
  }
  if (language) {
    lines.push(`language: "${language}"`);
  }
  if (coverPath) {
    lines.push(`cover: "${coverPath}"`);
  }
  lines.push("---");
  lines.push(`# ${book.title}`);
  if (book.author) {
    lines.push(`**Author:** ${book.author}`);
  }
  lines.push("");
  if (coverPath) {
    lines.push(`![[${coverPath}|200]]`);
    lines.push("");
  }
  if (progress !== null || currentChapter !== null || lastReadTimestamp !== null) {
    lines.push("> [!moonsync-reading-progress]+ Reading progress");
    if (progress !== null) {
      lines.push(`> - **Progress:** ${progress.toFixed(1)}%`);
    }
    if (currentChapter !== null) {
      lines.push(`> - **Chapter:** ${currentChapter}`);
    }
    if (lastReadTimestamp !== null) {
      lines.push(`> - **Last read:** ${formatDate(lastReadTimestamp)}`);
    }
    lines.push("");
  }
  const description = fetchedDescription || book.description;
  if (description && description.trim().length > 0) {
    lines.push("> [!moonsync-description]+ Description");
    const descLines = description.trim().split("\n");
    for (const line of descLines) {
      lines.push(`> ${line}`);
    }
    lines.push("");
  }
  if (highlights.length > 0) {
    lines.push("## Moon Reader highlights");
    lines.push("");
    for (const highlight of highlights) {
      lines.push(formatHighlight(highlight, settings.showHighlightColors));
      lines.push("");
    }
  }
  lines.push("## My notes");
  lines.push("");
  lines.push("> [!moonsync-user-notes]+ Your notes");
  lines.push("> Add your thoughts, analysis, and notes here. This section is preserved across syncs.");
  lines.push("");
  return lines.join("\n");
}
function formatHighlight(highlight, useColors) {
  const calloutType = useColors ? getCalloutType(highlight.highlightColor) : "quote";
  const dateStr = highlight.timestamp ? formatDate(highlight.timestamp) : "";
  const chapterStr = highlight.chapter > 0 ? `Chapter ${highlight.chapter}` : "";
  const headerParts = [chapterStr, dateStr].filter((p) => p);
  const header = headerParts.length > 0 ? headerParts.join(" \u2022 ") : "";
  const lines = [];
  if (header) {
    lines.push(`> [!${calloutType}] ${header}`);
  } else {
    lines.push(`> [!${calloutType}]`);
  }
  if (highlight.originalText) {
    const text = highlight.originalText.trim();
    const textLines = text.split("\n");
    for (const line of textLines) {
      lines.push(`> ${line}`);
    }
  }
  if (highlight.note && highlight.note.trim()) {
    lines.push(">");
    lines.push(`> ---`);
    lines.push(`> **Note:** ${highlight.note.trim()}`);
  }
  return lines.join("\n");
}
function parseCategory(categoryField) {
  const lines = categoryField.split("\n").map((l) => l.trim()).filter((l) => l && !l.startsWith("<") && !l.startsWith("#"));
  return lines[0] || "";
}
function generateFilename(title) {
  return title.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim().substring(0, 100);
}
function generateIndexNote(books, settings) {
  const lines = [];
  lines.push(`# ${settings.indexNoteTitle}`);
  lines.push("");
  if (settings.showCoverCollage) {
    const booksWithCovers = books.filter((b) => b.coverPath);
    if (booksWithCovers.length > 0) {
      let sortedCovers;
      if (settings.coverCollageSort === "recent") {
        sortedCovers = [...booksWithCovers].sort((a, b) => {
          const aTime = a.lastReadTimestamp || 0;
          const bTime = b.lastReadTimestamp || 0;
          if (bTime !== aTime)
            return bTime - aTime;
          return a.book.title.toLowerCase().localeCompare(b.book.title.toLowerCase());
        });
      } else {
        sortedCovers = [...booksWithCovers].sort(
          (a, b) => a.book.title.toLowerCase().localeCompare(b.book.title.toLowerCase())
        );
      }
      const coversToShow = settings.coverCollageLimit > 0 ? sortedCovers.slice(0, settings.coverCollageLimit) : sortedCovers;
      const coverImgs = coversToShow.map((book) => {
        const noteFilename = generateFilename(book.book.title);
        return `<a class="internal-link" href="${noteFilename}"><img src="${book.coverPath}" style="height: 120px; width: auto;"></a>`;
      }).join(" ");
      lines.push(coverImgs);
      lines.push("");
    }
  }
  const totalBooks = books.length;
  const totalHighlights = books.reduce((sum, b) => sum + b.highlights.length, 0);
  const totalNotes = books.reduce(
    (sum, b) => sum + b.highlights.filter((h) => h.note && h.note.trim()).length,
    0
  );
  const booksWithProgress = books.filter((b) => b.progress !== null);
  const avgProgress = booksWithProgress.length > 0 ? booksWithProgress.reduce((sum, b) => sum + (b.progress || 0), 0) / booksWithProgress.length : 0;
  lines.push("## Summary");
  lines.push(`- **Books:** ${totalBooks}`);
  lines.push(`- **Highlights:** ${totalHighlights}`);
  lines.push(`- **Notes:** ${totalNotes}`);
  if (booksWithProgress.length > 0) {
    lines.push(`- **Average progress:** ${avgProgress.toFixed(1)}%`);
  }
  lines.push("");
  lines.push("## Books");
  const sortedBooks = [...books].sort(
    (a, b) => a.book.title.toLowerCase().localeCompare(b.book.title.toLowerCase())
  );
  for (const bookData of sortedBooks) {
    const rawFilename = bookData.book.filename;
    const filename = rawFilename && !rawFilename.includes("/") ? rawFilename : generateFilename(bookData.book.title);
    const author = bookData.book.author ? ` by ${bookData.book.author}` : "";
    const progress = bookData.progress !== null ? ` (${bookData.progress.toFixed(0)}%)` : "";
    const highlightCount = bookData.highlights.length;
    const noteCount = bookData.highlights.filter((h) => h.note && h.note.trim()).length;
    const statsText = noteCount > 0 ? `${highlightCount} highlights, ${noteCount} ${noteCount === 1 ? "note" : "notes"}` : `${highlightCount} highlights`;
    lines.push(`- [[${filename}|${bookData.book.title}]]${author}${progress} \u2014 ${statsText}`);
  }
  lines.push("");
  return lines.join("\n");
}
function generateBaseFile(settings) {
  const outputFolder = settings.outputFolder;
  const indexTitle = settings.indexNoteTitle;
  const baseTitle = settings.baseFileName;
  const lines = [];
  lines.push("filters:");
  lines.push("  and:");
  lines.push(`    - file.folder == "${outputFolder}"`);
  lines.push(`    - file.name != "${indexTitle}"`);
  lines.push(`    - file.name != "${baseTitle}"`);
  lines.push('    - file.ext == "md"');
  lines.push("properties:");
  lines.push("  file.name:");
  lines.push("    displayName: Title");
  lines.push("  author:");
  lines.push("    displayName: Author");
  lines.push("  genres:");
  lines.push("    displayName: Genres");
  lines.push("  published_date:");
  lines.push("    displayName: Published");
  lines.push("  page_count:");
  lines.push("    displayName: Pages");
  lines.push("  highlights_count:");
  lines.push("    displayName: Highlights");
  lines.push("  notes_count:");
  lines.push("    displayName: Notes");
  lines.push("  last_synced:");
  lines.push("    displayName: Last synced");
  lines.push("  last_read:");
  lines.push("    displayName: Last read");
  lines.push("  publisher:");
  lines.push("    displayName: Publisher");
  lines.push("  series:");
  lines.push("    displayName: Series");
  lines.push("  language:");
  lines.push("    displayName: Language");
  lines.push("  progress:");
  lines.push("    displayName: Progress %");
  lines.push("  manual_note:");
  lines.push("    displayName: Manual");
  lines.push("views:");
  lines.push("  - type: table");
  lines.push("    name: Library");
  lines.push("    order:");
  lines.push("      - file.name");
  lines.push("      - author");
  lines.push("      - highlights_count");
  lines.push("      - progress");
  lines.push("      - notes_count");
  lines.push("      - manual_note");
  lines.push("      - last_read");
  lines.push("      - last_synced");
  lines.push("      - genres");
  lines.push("      - page_count");
  lines.push("      - publisher");
  lines.push("      - published_date");
  lines.push("      - language");
  lines.push("    limit: 100");
  lines.push("    properties:");
  lines.push("      - file.name");
  lines.push("      - note.author");
  lines.push("      - note.genres");
  lines.push("      - note.highlights_count");
  lines.push("      - note.notes_count");
  lines.push("      - note.progress");
  lines.push("      - note.manual_note");
  lines.push("      - note.published_date");
  lines.push("      - note.publisher");
  lines.push("      - note.page_count");
  lines.push("      - note.series");
  lines.push("      - note.language");
  lines.push("      - note.last_read");
  lines.push("      - note.last_synced");
  lines.push("  - type: cards");
  lines.push("    name: Gallery");
  lines.push("    order:");
  lines.push("      - file.name");
  lines.push("    limit: 100");
  lines.push("    image: note.cover");
  lines.push("    imageFit: contain");
  lines.push("    cardSize: medium");
  lines.push("    properties:");
  lines.push("      - file.name");
  lines.push("      - note.author");
  lines.push("      - note.published_date");
  return lines.join("\n");
}

// src/cache.ts
var import_obsidian5 = require("obsidian");
var CACHE_FILE = ".moonsync-cache.json";
function getCacheKey(title, author) {
  return `${title.toLowerCase()}|${author.toLowerCase()}`;
}
async function loadCache(app, outputFolder) {
  const cachePath = (0, import_obsidian5.normalizePath)(`${outputFolder}/${CACHE_FILE}`);
  try {
    if (await app.vault.adapter.exists(cachePath)) {
      const data = await app.vault.adapter.read(cachePath);
      return JSON.parse(data);
    }
  } catch (error) {
    console.debug("MoonSync: Failed to load cache, starting fresh", error);
  }
  return {};
}
async function saveCache(app, outputFolder, cache) {
  const cachePath = (0, import_obsidian5.normalizePath)(`${outputFolder}/${CACHE_FILE}`);
  try {
    await app.vault.adapter.write(cachePath, JSON.stringify(cache, null, 2));
  } catch (error) {
    console.debug("MoonSync: Failed to save cache", error);
  }
}
function getCachedInfo(cache, title, author) {
  const key = getCacheKey(title, author);
  return cache[key] || null;
}
function setCachedInfo(cache, title, author, info) {
  const key = getCacheKey(title, author);
  cache[key] = {
    ...info,
    fetchedAt: Date.now()
  };
}

// src/scanner.ts
var import_obsidian6 = require("obsidian");
async function scanAllBookNotes(app, outputPath) {
  const books = [];
  const normalizedPath = (0, import_obsidian6.normalizePath)(outputPath);
  if (!await app.vault.adapter.exists(normalizedPath)) {
    return books;
  }
  const listing = await app.vault.adapter.list(normalizedPath);
  for (const filePath of listing.files) {
    if (!filePath.endsWith(".md"))
      continue;
    try {
      const content = await app.vault.adapter.read(filePath);
      const bookData = parseBookFrontmatter(content, filePath);
      if (bookData) {
        books.push(bookData);
      }
    } catch (error) {
      console.debug(`MoonSync: Failed to read ${filePath}`, error);
    }
  }
  return books;
}
function parseBookFrontmatter(content, filePath) {
  var _a;
  const parsed = parseFrontmatter(content);
  if (!parsed.title) {
    return null;
  }
  const notesCount = (content.match(/\*\*Note:\*\*/g) || []).length;
  let lastReadTimestamp = null;
  if (parsed.lastSynced) {
    lastReadTimestamp = new Date(parsed.lastSynced).getTime();
  }
  return {
    title: parsed.title,
    author: parsed.author,
    progress: parsed.progress,
    highlightsCount: (_a = parsed.highlightsCount) != null ? _a : 0,
    notesCount,
    coverPath: parsed.coverPath,
    lastReadTimestamp,
    filePath,
    isMoonReader: !!parsed.moonReaderPath
  };
}
function scannedBookToBookData(scanned) {
  const filenameWithExt = scanned.filePath.split("/").pop() || "";
  const actualFilename = filenameWithExt.replace(/\.md$/, "");
  const book = {
    id: 0,
    title: scanned.title,
    filename: actualFilename,
    // Store actual filename for index links
    author: scanned.author || "",
    description: "",
    category: "",
    thumbFile: "",
    coverFile: "",
    addTime: "",
    favorite: ""
  };
  const highlights = [];
  for (let i = 0; i < scanned.highlightsCount; i++) {
    highlights.push({
      id: i,
      book: scanned.title,
      filename: "",
      chapter: 0,
      position: 0,
      highlightLength: 0,
      highlightColor: 0,
      timestamp: 0,
      bookmark: "",
      note: i < scanned.notesCount ? "note" : "",
      // Mark first N as having notes
      originalText: "",
      underline: false,
      strikethrough: false
    });
  }
  return {
    book,
    highlights,
    statistics: null,
    progress: scanned.progress,
    currentChapter: null,
    lastReadTimestamp: scanned.lastReadTimestamp,
    coverPath: scanned.coverPath,
    fetchedDescription: null,
    publishedDate: null,
    publisher: null,
    pageCount: null,
    genres: null,
    series: null,
    isbn10: null,
    isbn13: null,
    language: null,
    previousTitle: null
  };
}
function mergeBookLists(moonReaderBooks, scannedBooks) {
  const result = [...moonReaderBooks];
  const moonReaderMap = /* @__PURE__ */ new Map();
  for (const book of result) {
    moonReaderMap.set(book.book.title.toLowerCase(), book);
  }
  function findMoonReaderBook(scannedTitle) {
    const scannedLower = scannedTitle.toLowerCase();
    const exactMatch = moonReaderMap.get(scannedLower);
    if (exactMatch)
      return exactMatch;
    for (const [moonTitle, book] of moonReaderMap) {
      if (scannedLower.startsWith(moonTitle) || moonTitle.startsWith(scannedLower)) {
        return book;
      }
    }
    return void 0;
  }
  for (const scanned of scannedBooks) {
    const moonReaderBook = findMoonReaderBook(scanned.title);
    if (moonReaderBook) {
      const filenameWithExt = scanned.filePath.split("/").pop() || "";
      const actualFilename = filenameWithExt.replace(/\.md$/, "");
      moonReaderBook.book.filename = actualFilename;
      moonReaderBook.book.title = scanned.title;
      if (scanned.coverPath) {
        moonReaderBook.coverPath = scanned.coverPath;
      }
    } else {
      result.push(scannedBookToBookData(scanned));
    }
  }
  return result;
}

// src/sync.ts
init_hardcover();

// src/parser/books-sync.ts
var import_promises2 = require("fs/promises");
var import_path3 = require("path");
var import_zlib2 = require("zlib");
async function parseBooksSyncFile(syncPath) {
  const filePath = (0, import_path3.join)(syncPath, ".Moon+", "books.sync");
  try {
    const data = await (0, import_promises2.readFile)(filePath);
    const decompressed = (0, import_zlib2.inflateSync)(data).toString("utf-8");
    const entries = JSON.parse(decompressed);
    const map = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      if (entry.filename) {
        map.set(entry.filename.toLowerCase().normalize("NFC"), entry);
      }
    }
    return map;
  } catch (e) {
    return null;
  }
}
function parseCategoryField(category) {
  const lines = category.split("\n").map((l) => l.trim()).filter((l) => l);
  let series = null;
  let seriesNumber = null;
  const genres = [];
  for (const line of lines) {
    if (line.startsWith("<") && line.endsWith(">")) {
      series = line.slice(1, -1);
    } else if (line.startsWith("#") && line.endsWith("#")) {
      const num = parseFloat(line.slice(1, -1));
      if (!isNaN(num)) {
        seriesNumber = num;
      }
    } else {
      genres.push(line);
    }
  }
  return { series, seriesNumber, genres };
}

// src/parser/local-covers.ts
var import_promises3 = require("fs/promises");
var import_path4 = require("path");
async function scanLocalCovers(syncPath) {
  const coverDir = (0, import_path4.join)(syncPath, ".Moon+", "Cover");
  const available = /* @__PURE__ */ new Set();
  try {
    const files = await (0, import_promises3.readdir)(coverDir);
    for (const f of files) {
      if (f.endsWith("_2.png")) {
        const bookFilename = f.slice(0, -6);
        available.add(bookFilename.toLowerCase().normalize("NFC"));
      }
    }
  } catch (e) {
  }
  return available;
}
async function getLocalCover(syncPath, bookFilename) {
  const coverPath = (0, import_path4.join)(syncPath, ".Moon+", "Cover", `${bookFilename}_2.png`);
  try {
    const data = await (0, import_promises3.readFile)(coverPath);
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  } catch (e) {
    return null;
  }
}

// src/parser/mrpro.ts
var import_jszip = __toESM(require_jszip_min());
var import_promises4 = require("fs/promises");
var import_path5 = require("path");
async function findLatestBackup(backupDir) {
  try {
    const files = await (0, import_promises4.readdir)(backupDir);
    const mrproFiles = files.filter((f) => f.endsWith(".mrpro"));
    if (mrproFiles.length === 0) {
      return null;
    }
    const filesWithStats = await Promise.all(
      mrproFiles.map(async (f) => {
        const filePath = (0, import_path5.join)(backupDir, f);
        const stats = await (0, import_promises4.stat)(filePath);
        return { path: filePath, mtime: stats.mtime.getTime() };
      })
    );
    filesWithStats.sort((a, b) => b.mtime - a.mtime);
    return filesWithStats[0].path;
  } catch (error) {
    console.error("Error finding backup files:", error);
    return null;
  }
}
function parseNamesList(content) {
  const mapping = /* @__PURE__ */ new Map();
  const lines = content.split("\n").filter((line) => line.trim());
  lines.forEach((line, index) => {
    const tagFile = `${index + 1}.tag`;
    const actualPath = line.trim();
    mapping.set(tagFile, actualPath);
  });
  return mapping;
}
async function extractMrpro(mrproPath) {
  const fileBuffer = await (0, import_promises4.readFile)(mrproPath);
  const zip = await import_jszip.default.loadAsync(fileBuffer);
  const namesListFile = zip.file(/.*_names\.list$/);
  if (!namesListFile || namesListFile.length === 0) {
    throw new Error("Could not find _names.list in backup");
  }
  const namesContent = await namesListFile[0].async("string");
  const namesMapping = parseNamesList(namesContent);
  let dbTagFile = null;
  for (const [tagFile, actualPath] of namesMapping.entries()) {
    if (actualPath.includes("mrbooks.db")) {
      dbTagFile = tagFile;
      break;
    }
  }
  if (!dbTagFile) {
    throw new Error("Could not find mrbooks.db in backup");
  }
  const dbFile = zip.file(new RegExp(`.*/${dbTagFile}$`));
  if (!dbFile || dbFile.length === 0) {
    throw new Error(`Could not extract database file: ${dbTagFile}`);
  }
  const database = await dbFile[0].async("arraybuffer");
  return {
    database,
    namesMapping
  };
}

// src/parser/database.ts
var import_sql = __toESM(require_sql_wasm());
var import_promises5 = require("fs/promises");
var SQL = null;
async function initDatabase(wasmPath) {
  if (!SQL) {
    const wasmBinary = await (0, import_promises5.readFile)(wasmPath);
    SQL = await (0, import_sql.default)({
      wasmBinary
    });
  }
}

// src/enrichment.ts
var import_sql2 = __toESM(require_sql_wasm());
var import_promises6 = require("fs/promises");
var import_path6 = require("path");
async function extractBackupStatistics(syncPath, wasmPath) {
  const backupDir = (0, import_path6.join)(syncPath, ".Moon+", "Backup");
  try {
    const latestBackup = await findLatestBackup(backupDir);
    if (!latestBackup)
      return null;
    const mrpro = await extractMrpro(latestBackup);
    await initDatabase(wasmPath);
    const wasmBinary = await (0, import_promises6.readFile)(wasmPath);
    const SQL2 = await (0, import_sql2.default)({ wasmBinary });
    const db = new SQL2.Database(new Uint8Array(mrpro.database));
    try {
      const results = db.exec(
        "SELECT _id, filename, usedTime, readWords, dates FROM statistics"
      );
      if (results.length === 0)
        return /* @__PURE__ */ new Map();
      const statsMap = /* @__PURE__ */ new Map();
      for (const row of results[0].values) {
        const fullPath = row[1] || "";
        const basename = (fullPath.includes("/") ? (fullPath.split("/").pop() || "").toLowerCase() : fullPath.toLowerCase()).normalize("NFC");
        if (basename) {
          statsMap.set(basename, {
            id: row[0],
            filename: fullPath,
            usedTime: row[2] || 0,
            readWords: row[3] || 0,
            dates: row[4] || ""
          });
        }
      }
      return statsMap;
    } finally {
      db.close();
    }
  } catch (error) {
    console.debug("MoonSync: Failed to extract backup statistics", error);
    return null;
  }
}
function enrichFromSyncEntry(bookData, entry) {
  if (entry.bookName && entry.bookName !== bookData.book.title && entry.bookName.length >= 3 && !/^[0-9a-f-]{16,}$/i.test(entry.bookName)) {
    bookData.previousTitle = bookData.book.title;
    bookData.book.title = entry.bookName;
  }
  if (!bookData.book.author && entry.author) {
    bookData.book.author = entry.author;
  }
  if (!bookData.book.description && entry.description) {
    bookData.book.description = entry.description;
  }
  if (!bookData.book.category && entry.category) {
    bookData.book.category = entry.category;
  }
  if (entry.category) {
    const parsed = parseCategoryField(entry.category);
    if (!bookData.genres && parsed.genres.length > 0) {
      bookData.genres = parsed.genres;
    }
    if (!bookData.series && parsed.series) {
      bookData.series = parsed.seriesNumber ? `${parsed.series} #${parsed.seriesNumber}` : parsed.series;
    }
  }
  if (!bookData.book.favorite && entry.favorite) {
    bookData.book.favorite = entry.favorite;
  }
}
async function enrichBooksWithSyncData(books, syncPath, wasmPath, trackBooksWithoutHighlights = false) {
  const result = {
    booksEnriched: 0,
    coversFound: 0,
    statisticsFound: 0
  };
  const sufficientMetadata = /* @__PURE__ */ new Set();
  const [booksSyncMap, localCovers, backupStats] = await Promise.all([
    parseBooksSyncFile(syncPath),
    scanLocalCovers(syncPath),
    extractBackupStatistics(syncPath, wasmPath)
  ]);
  const matchedSyncKeys = /* @__PURE__ */ new Set();
  for (let i = 0; i < books.length; i++) {
    const bookData = books[i];
    const epubFilename = bookData.book.filename;
    if (!epubFilename)
      continue;
    const key = epubFilename.toLowerCase().normalize("NFC");
    console.log(`[enrichment] Book "${bookData.book.title}" key="${key}" (len=${key.length})`);
    if (booksSyncMap) {
      const syncEntry = booksSyncMap.get(key);
      if (syncEntry) {
        console.log(`[enrichment]   MATCHED books.sync entry`);
        matchedSyncKeys.add(key);
        enrichFromSyncEntry(bookData, syncEntry);
        result.booksEnriched++;
        if (bookData.book.title && bookData.book.author && bookData.book.description) {
          sufficientMetadata.add(i);
        }
      }
    }
    if (localCovers.has(key)) {
      bookData.book.coverFile = epubFilename;
      result.coversFound++;
    }
    if (backupStats) {
      const stats = backupStats.get(key);
      if (stats && !bookData.statistics) {
        bookData.statistics = stats;
        result.statisticsFound++;
      }
    }
  }
  if (trackBooksWithoutHighlights && booksSyncMap) {
    console.log(`[enrichment] matchedSyncKeys: ${[...matchedSyncKeys].join(", ")}`);
    for (const [key, entry] of booksSyncMap) {
      if (matchedSyncKeys.has(key)) {
        console.log(`[enrichment] books.sync "${entry.filename}" already matched, skipping`);
        continue;
      }
      console.log(`[enrichment] books.sync "${entry.filename}" UNMATCHED key="${key}" \u2014 creating new BookData`);
      const parsed = entry.category ? parseCategoryField(entry.category) : null;
      const hasValidBookName = entry.bookName && entry.bookName.length >= 3 && !/^[0-9a-f-]{16,}$/i.test(entry.bookName);
      const title = hasValidBookName ? entry.bookName : entry.filename.replace(/\.(epub|mobi|pdf|azw3?|fb2|txt)$/i, "").trim();
      const bookData = {
        book: {
          id: 0,
          title,
          filename: entry.filename,
          author: entry.author || "",
          description: entry.description || "",
          category: entry.category || "",
          thumbFile: "",
          coverFile: localCovers.has(key) ? entry.filename : "",
          addTime: entry.addTime || "",
          favorite: entry.favorite || ""
        },
        highlights: [],
        statistics: (backupStats == null ? void 0 : backupStats.get(key)) || null,
        progress: null,
        currentChapter: null,
        lastReadTimestamp: null,
        coverPath: null,
        fetchedDescription: null,
        publishedDate: null,
        publisher: null,
        pageCount: null,
        genres: (parsed == null ? void 0 : parsed.genres.length) ? parsed.genres : null,
        series: (parsed == null ? void 0 : parsed.series) ? parsed.seriesNumber ? `${parsed.series} #${parsed.seriesNumber}` : parsed.series : null,
        isbn10: null,
        isbn13: null,
        language: null,
        previousTitle: null
      };
      const idx = books.length;
      books.push(bookData);
      result.booksEnriched++;
      if (localCovers.has(key))
        result.coversFound++;
      if (bookData.statistics)
        result.statisticsFound++;
      if (bookData.book.title && bookData.book.author && bookData.book.description) {
        sufficientMetadata.add(idx);
      }
    }
  }
  return { enrichmentResult: result, booksWithSufficientMetadata: sufficientMetadata };
}

// src/sync.ts
async function syncFromMoonReader(app, settings, wasmPath) {
  const result = {
    success: false,
    booksProcessed: 0,
    booksCreated: 0,
    booksUpdated: 0,
    booksSkipped: 0,
    booksDeleted: 0,
    manualBooksAdded: 0,
    totalHighlights: 0,
    totalNotes: 0,
    isFirstSync: false,
    errors: [],
    failedBooks: []
  };
  const progressNotice = new import_obsidian7.Notice("MoonSync: Syncing...", 0);
  try {
    if (!settings.syncPath) {
      result.errors.push("Sync path not configured");
      progressNotice.hide();
      return result;
    }
    const booksWithHighlights = await parseAnnotationFiles(settings.syncPath, settings.trackBooksWithoutHighlights);
    progressNotice.setMessage("MoonSync: Enriching book metadata...");
    const { enrichmentResult, booksWithSufficientMetadata } = await enrichBooksWithSyncData(booksWithHighlights, settings.syncPath, wasmPath, settings.trackBooksWithoutHighlights);
    if (enrichmentResult.booksEnriched > 0) {
      console.log(
        `MoonSync: Enriched ${enrichmentResult.booksEnriched} books from sync data (${enrichmentResult.coversFound} covers, ${enrichmentResult.statisticsFound} statistics)`
      );
    }
    if (booksWithHighlights.length === 0) {
      result.errors.push("No books found in .Moon+/Cache folder or books.sync");
      progressNotice.hide();
      return result;
    }
    const outputPath = (0, import_obsidian7.normalizePath)(settings.outputFolder);
    const outputFolderExisted = await app.vault.adapter.exists(outputPath);
    result.isFirstSync = !outputFolderExisted;
    if (!outputFolderExisted) {
      await app.vault.createFolder(outputPath);
    }
    result.totalHighlights = booksWithHighlights.reduce((sum, b) => sum + b.highlights.length, 0);
    result.totalNotes = booksWithHighlights.reduce(
      (sum, b) => sum + b.highlights.filter((h) => h.note && h.note.trim()).length,
      0
    );
    const cache = await loadCache(app, outputPath);
    let cacheModified = false;
    progressNotice.setMessage("MoonSync: Scanning existing notes...");
    const titleCache = await buildTitleCache(app, outputPath);
    progressNotice.setMessage("MoonSync: Fetching book metadata...");
    const coversFolder = (0, import_obsidian7.normalizePath)(`${outputPath}/moonsync-covers`);
    let existingCoversSet = /* @__PURE__ */ new Set();
    try {
      if (await app.vault.adapter.exists(coversFolder)) {
        const listing = await app.vault.adapter.list(coversFolder);
        existingCoversSet = new Set(listing.files.map((f) => f.split("/").pop() || ""));
      }
    } catch (e) {
    }
    const booksToFetch = [];
    for (let i = 0; i < booksWithHighlights.length; i++) {
      const bookData = booksWithHighlights[i];
      if (booksWithSufficientMetadata.has(i)) {
        const coverFilename2 = `${generateFilename(bookData.book.title)}.jpg`;
        const hasCover = existingCoversSet.has(coverFilename2) || !!bookData.book.coverFile;
        if (hasCover)
          continue;
      }
      const cachedInfo = getCachedInfo(cache, bookData.book.title, bookData.book.author);
      const hasAttemptedFetch = cachedInfo && (cachedInfo.publishedDate !== void 0 && cachedInfo.publisher !== void 0 && cachedInfo.pageCount !== void 0);
      const coverFilename = `${generateFilename(bookData.book.title)}.jpg`;
      const coverExists = existingCoversSet.has(coverFilename);
      if (!coverExists || !hasAttemptedFetch) {
        booksToFetch.push({ title: bookData.book.title, author: bookData.book.author });
      }
    }
    const prefetchedInfo = booksToFetch.length > 0 ? await batchFetchBookInfo(booksToFetch, 5) : /* @__PURE__ */ new Map();
    const totalBooks = booksWithHighlights.length;
    const changedBookTitles = /* @__PURE__ */ new Set();
    for (let i = 0; i < booksWithHighlights.length; i++) {
      const bookData = booksWithHighlights[i];
      progressNotice.setMessage(`MoonSync: ${bookData.book.title} (${i + 1}/${totalBooks})`);
      try {
        const prevCreated = result.booksCreated;
        const prevUpdated = result.booksUpdated;
        const processed = await processBook(app, outputPath, bookData, settings, result, cache, prefetchedInfo, titleCache);
        if (processed) {
          cacheModified = true;
        }
        if (result.booksCreated > prevCreated || result.booksUpdated > prevUpdated) {
          changedBookTitles.add(bookData.book.title);
        }
        result.booksProcessed++;
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        result.failedBooks.push({
          title: bookData.book.title,
          error: errorMsg
        });
        result.errors.push(`Error processing "${bookData.book.title}": ${errorMsg}`);
      }
    }
    const scannedBooks = await scanAllBookNotes(app, outputPath);
    const customBooks = scannedBooks.filter((book) => !book.isMoonReader);
    if (customBooks.length > 0) {
      const totalCustom = customBooks.length;
      for (let i = 0; i < customBooks.length; i++) {
        const customBook = customBooks[i];
        progressNotice.setMessage(`MoonSync: ${customBook.title} (${i + 1}/${totalCustom} custom)`);
        try {
          const processed = await processCustomBook(app, outputPath, customBook, settings, result, cache);
          if (processed) {
            cacheModified = true;
          }
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          result.failedBooks.push({
            title: customBook.title,
            error: errorMsg
          });
          result.errors.push(`Error processing custom book "${customBook.title}": ${errorMsg}`);
        }
      }
    }
    if (cacheModified) {
      await saveCache(app, outputPath, cache);
    }
    if (settings.hardcoverEnabled && settings.hardcoverToken) {
      try {
        progressNotice.setMessage("MoonSync: Syncing to Hardcover...");
        console.log(`MoonSync: Hardcover sync starting \u2014 ${changedBookTitles.size} changed books, ${booksWithHighlights.length} total books`);
        const hardcoverItems = [];
        for (const b of booksWithHighlights) {
          if (b.progress === null) {
            console.log(`MoonSync: Hardcover skipping "${b.book.title}" \u2014 no progress data`);
            continue;
          }
          const filename = generateFilename(b.book.title);
          const filePath = (0, import_obsidian7.normalizePath)(`${outputPath}/${filename}.md`);
          let hardcoverId = null;
          let lastSyncedProgress = null;
          try {
            if (await app.vault.adapter.exists(filePath)) {
              const content = await app.vault.adapter.read(filePath);
              const fm = extractFrontmatter(content);
              if (fm) {
                const idStr = parseFrontmatterField(fm, "hardcover_id");
                if (idStr)
                  hardcoverId = parseInt(idStr, 10) || null;
                lastSyncedProgress = parseFrontmatterField(fm, "hardcover_progress");
              }
            } else {
              console.log(`MoonSync: Hardcover "${b.book.title}" \u2014 note not found at ${filePath}`);
            }
          } catch (e) {
          }
          const currentProgress = b.progress.toFixed(1);
          if (lastSyncedProgress && lastSyncedProgress.replace(/["%]/g, "") === currentProgress) {
            console.log(`MoonSync: Hardcover skipping "${b.book.title}" \u2014 progress unchanged (${currentProgress}%)`);
            continue;
          }
          console.log(`MoonSync: Hardcover queuing "${b.book.title}" \u2014 progress: ${b.progress}%, hardcoverId: ${hardcoverId}, lastSynced: ${lastSyncedProgress}`);
          hardcoverItems.push({
            title: b.book.title,
            author: b.book.author,
            progress: b.progress,
            hardcoverId
          });
        }
        console.log(`MoonSync: Hardcover ${hardcoverItems.length} books queued for sync`);
        if (hardcoverItems.length > 0) {
          const hcResult = await syncBooksToHardcover(
            hardcoverItems,
            settings.hardcoverToken,
            (msg) => progressNotice.setMessage(`MoonSync: ${msg}`)
          );
          result.hardcoverUpdated = hcResult.booksUpdated;
          console.log(`MoonSync: Hardcover write-back \u2014 ${hcResult.updatedTitles.length} updated, ${hcResult.newIds.length} new IDs, ${hcResult.slugs.size} slugs`);
          const newIdMap = new Map(hcResult.newIds.map((n) => [n.title, n.hardcoverId]));
          const newSlugMap = new Map(hcResult.newIds.map((n) => [n.title, n.slug]));
          const progressMap = new Map(hardcoverItems.map((i) => [i.title, i.progress]));
          for (const title of hcResult.updatedTitles) {
            try {
              const fn = generateFilename(title);
              const fp = (0, import_obsidian7.normalizePath)(`${outputPath}/${fn}.md`);
              if (await app.vault.adapter.exists(fp)) {
                let content = await app.vault.adapter.read(fp);
                const existingIdMatch = content.match(/^hardcover_id: (.+)$/m);
                const existingId = existingIdMatch ? existingIdMatch[1].trim() : null;
                content = content.replace(/^hardcover_id: .*\n/m, "");
                content = content.replace(/^hardcover_progress: .*\n/m, "");
                content = content.replace(/^hardcover_url: .*\n/m, "");
                const newId = newIdMap.get(title);
                const hardcoverId = newId || existingId;
                const slug = hcResult.slugs.get(title) || newSlugMap.get(title);
                const syncedProgress = progressMap.get(title);
                const fields = [];
                if (hardcoverId)
                  fields.push(`hardcover_id: ${hardcoverId}`);
                if (slug)
                  fields.push(`hardcover_url: "https://hardcover.app/books/${slug}"`);
                if (syncedProgress !== null && syncedProgress !== void 0) {
                  fields.push(`hardcover_progress: "${syncedProgress.toFixed(1)}%"`);
                }
                if (fields.length > 0) {
                  content = content.replace(/\n---\n/, `
${fields.join("\n")}
---
`);
                }
                await app.vault.adapter.write(fp, content);
              }
            } catch (err) {
              console.log(`MoonSync: Failed to write hardcover data for "${title}"`, err);
            }
          }
        }
      } catch (error) {
        console.log("MoonSync: Hardcover sync failed", error);
      }
    }
    if (settings.showIndex) {
      const indexPath = (0, import_obsidian7.normalizePath)(`${outputPath}/${settings.indexNoteTitle}.md`);
      const indexExists = await app.vault.adapter.exists(indexPath);
      const indexFilename = `${settings.indexNoteTitle}.md`;
      const filteredScanned = scannedBooks.filter((b) => !b.filePath.endsWith(indexFilename));
      const totalBookNotes = filteredScanned.length;
      const manualBookCount = totalBookNotes - booksWithHighlights.length;
      const hasManualBooks = manualBookCount > 0;
      if (hasManualBooks) {
        result.manualBooksAdded = manualBookCount;
      }
      if (result.booksCreated > 0 || result.booksUpdated > 0 || result.booksDeleted > 0 || !indexExists || hasManualBooks) {
        const coversFolder2 = (0, import_obsidian7.normalizePath)(`${outputPath}/moonsync-covers`);
        let existingCovers = /* @__PURE__ */ new Set();
        try {
          if (await app.vault.adapter.exists(coversFolder2)) {
            const listing = await app.vault.adapter.list(coversFolder2);
            existingCovers = new Set(listing.files.map((f) => f.split("/").pop() || ""));
          }
        } catch (e) {
        }
        for (const bookData of booksWithHighlights) {
          if (!bookData.coverPath) {
            const coverFilename = `${generateFilename(bookData.book.title)}.jpg`;
            if (existingCovers.has(coverFilename)) {
              bookData.coverPath = `moonsync-covers/${coverFilename}`;
            }
          }
        }
        await updateIndexNote(app, outputPath, booksWithHighlights, settings);
      }
    }
    if (settings.generateBaseFile) {
      const baseFilePath = (0, import_obsidian7.normalizePath)(`${outputPath}/${settings.baseFileName}.base`);
      const baseExists = await app.vault.adapter.exists(baseFilePath);
      if (result.booksCreated > 0 || result.booksUpdated > 0 || result.booksDeleted > 0 || !baseExists) {
        await updateBaseFile(app, outputPath, settings);
      }
    }
    progressNotice.hide();
    result.success = true;
    return result;
  } catch (error) {
    progressNotice.hide();
    result.errors.push(`Sync failed: ${error}`);
    return result;
  }
}
async function getExistingBookData(app, filePath) {
  try {
    if (!await app.vault.adapter.exists(filePath)) {
      return null;
    }
    const content = await app.vault.adapter.read(filePath);
    const parsed = parseFrontmatter(content);
    if (parsed.highlightsCount !== null) {
      return {
        highlightsCount: parsed.highlightsCount,
        highlightsHash: parsed.highlightsHash,
        progress: parsed.progress,
        lastRead: parsed.lastRead,
        isManualNote: parsed.isManualNote,
        hasCustomMetadata: parsed.hasCustomMetadata,
        fullContent: content
      };
    }
  } catch (e) {
  }
  return null;
}
function mergeManualNoteWithMoonReader(existingContent, bookData, settings) {
  const lines = [];
  const frontmatterMatch = existingContent.match(/^---\n([\s\S]*?)\n---/);
  const contentAfterFrontmatter = frontmatterMatch ? existingContent.slice(frontmatterMatch[0].length).trim() : existingContent.trim();
  lines.push("---");
  if (frontmatterMatch) {
    const frontmatter = frontmatterMatch[1];
    const frontmatterLines = frontmatter.split("\n");
    for (const line of frontmatterLines) {
      if (line.startsWith("progress:") || line.startsWith("current_chapter:") || line.startsWith("highlights_count:") || line.startsWith("highlights_hash:") || line.startsWith("notes_count:") || line.startsWith("last_synced:") || line.startsWith("manual_note:") || line.startsWith("published_date:") || line.startsWith("publisher:") || line.startsWith("page_count:") || line.startsWith("genres:") || line.startsWith("series:") || line.startsWith("language:") || line.trim().startsWith("-")) {
        continue;
      }
      lines.push(line);
    }
  }
  lines.push(`last_synced: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  lines.push(`highlights_count: ${bookData.highlights.length}`);
  lines.push(`highlights_hash: "${computeHighlightsHash(bookData.highlights)}"`);
  const notesCount = bookData.highlights.filter((h) => h.note && h.note.trim()).length;
  lines.push(`notes_count: ${notesCount}`);
  if (settings.showReadingProgress && bookData.progress !== null) {
    lines.push(`progress: "${bookData.progress.toFixed(1)}%"`);
    if (bookData.currentChapter) {
      lines.push(`current_chapter: ${bookData.currentChapter}`);
    }
  }
  if (bookData.publishedDate) {
    lines.push(`published_date: "${bookData.publishedDate.replace(/"/g, '\\"')}"`);
  }
  if (bookData.publisher) {
    lines.push(`publisher: "${bookData.publisher.replace(/"/g, '\\"')}"`);
  }
  if (bookData.pageCount !== null) {
    lines.push(`page_count: ${bookData.pageCount}`);
  }
  if (bookData.genres && bookData.genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of bookData.genres) {
      lines.push(`  - "${genre.replace(/"/g, '\\"')}"`);
    }
  }
  if (bookData.series) {
    lines.push(`series: "${bookData.series.replace(/"/g, '\\"')}"`);
  }
  if (bookData.language) {
    lines.push(`language: "${bookData.language}"`);
  }
  lines.push("---");
  lines.push("");
  lines.push(contentAfterFrontmatter);
  lines.push("");
  lines.push("## Moon Reader highlights");
  lines.push("");
  if (settings.showReadingProgress && (bookData.progress !== null || bookData.currentChapter !== null)) {
    lines.push("**Reading progress:**");
    if (bookData.progress !== null) {
      lines.push(`- Progress: ${bookData.progress.toFixed(1)}%`);
    }
    if (bookData.currentChapter !== null) {
      lines.push(`- Chapter: ${bookData.currentChapter}`);
    }
    lines.push("");
  }
  for (const highlight of bookData.highlights) {
    lines.push(formatHighlight(highlight, settings.showHighlightColors));
    lines.push("");
  }
  return lines.join("\n");
}
function hasUserNotes(content) {
  const myNotesPattern = /\n## My [Nn]otes\n([\s\S]*?)(?=\n## |\n---|\s*$)/;
  const myNotesMatch = content.match(myNotesPattern);
  if (!myNotesMatch) {
    return false;
  }
  let notesSection = myNotesMatch[1].trim();
  const placeholderPattern = /^> \[!moonsync-user-notes\]\+ Your [Nn]otes\n> Add your thoughts, analysis, and notes here\. This section is preserved across syncs\.\n?/;
  notesSection = notesSection.replace(placeholderPattern, "").trim();
  return notesSection.length > 0;
}
function mergeExistingNoteWithHighlights(existingContent, bookData, settings) {
  const myNotesPattern = /\n## My [Nn]otes\n([\s\S]*?)(?=\n## |\n---|\s*$)/;
  const myNotesMatch = existingContent.match(myNotesPattern);
  let userNotesContent = "";
  if (myNotesMatch) {
    let notesSection = myNotesMatch[1];
    const placeholderPattern = /^> \[!moonsync-user-notes\]\+ Your [Nn]otes\n> Add your thoughts, analysis, and notes here\. This section is preserved across syncs\.\n?/;
    notesSection = notesSection.replace(placeholderPattern, "").trim();
    if (notesSection) {
      userNotesContent = notesSection;
    }
  }
  const hardcoverFields = [];
  const hcIdMatch = existingContent.match(/^hardcover_id: .+$/m);
  if (hcIdMatch)
    hardcoverFields.push(hcIdMatch[0]);
  const hcUrlMatch = existingContent.match(/^hardcover_url: .+$/m);
  if (hcUrlMatch)
    hardcoverFields.push(hcUrlMatch[0]);
  const hcProgressMatch = existingContent.match(/^hardcover_progress: .+$/m);
  if (hcProgressMatch)
    hardcoverFields.push(hcProgressMatch[0]);
  let freshNote = generateBookNote(bookData, settings);
  if (hardcoverFields.length > 0) {
    freshNote = freshNote.replace(/\n---\n/, `
${hardcoverFields.join("\n")}
---
`);
  }
  if (userNotesContent) {
    const placeholderInFresh = "> [!moonsync-user-notes]+ Your notes\n> Add your thoughts, analysis, and notes here. This section is preserved across syncs.";
    freshNote = freshNote.replace(placeholderInFresh, userNotesContent);
  }
  return freshNote;
}
function calculateSimilarity(str1, str2) {
  const s1 = str1.toLowerCase();
  const s2 = str2.toLowerCase();
  if (s1 === s2)
    return 1;
  const len1 = s1.length;
  const len2 = s2.length;
  if (len1 === 0)
    return len2 === 0 ? 1 : 0;
  if (len2 === 0)
    return 0;
  const matrix = [];
  for (let i = 0; i <= len1; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= len2; j++) {
    matrix[0][j] = j;
  }
  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        // deletion
        matrix[i][j - 1] + 1,
        // insertion
        matrix[i - 1][j - 1] + cost
        // substitution
      );
    }
  }
  const distance = matrix[len1][len2];
  const maxLen = Math.max(len1, len2);
  return 1 - distance / maxLen;
}
function normalizeBookTitle2(title) {
  return title.replace(/\.(epub|mobi|pdf|azw3?|fb2|txt)$/i, "").trim();
}
async function buildTitleCache(app, outputPath) {
  const cache = [];
  try {
    const listing = await app.vault.adapter.list((0, import_obsidian7.normalizePath)(outputPath));
    for (const filePath of listing.files) {
      if (!filePath.endsWith(".md"))
        continue;
      try {
        const content = await app.vault.adapter.read(filePath);
        const parsed = parseFrontmatter(content);
        if (parsed.title) {
          cache.push({
            normalizedTitle: normalizeBookTitle2(parsed.title),
            filePath
          });
        }
      } catch (e) {
      }
    }
  } catch (e) {
  }
  return cache;
}
var SIMILARITY_THRESHOLD = 0.8;
async function findExistingFile(app, outputPath, preferredFilename, bookTitle, titleCache, previousTitle = null) {
  const preferredPath = (0, import_obsidian7.normalizePath)(`${outputPath}/${preferredFilename}.md`);
  if (await app.vault.adapter.exists(preferredPath)) {
    return preferredPath;
  }
  if (previousTitle) {
    const oldFilename = generateFilename(previousTitle);
    const oldPath = (0, import_obsidian7.normalizePath)(`${outputPath}/${oldFilename}.md`);
    if (oldPath !== preferredPath && await app.vault.adapter.exists(oldPath)) {
      try {
        await app.vault.adapter.rename(oldPath, preferredPath);
        console.log(`MoonSync: Renamed "${oldFilename}.md" \u2192 "${preferredFilename}.md"`);
        return preferredPath;
      } catch (e) {
        return oldPath;
      }
    }
  }
  const normalizedBookTitle = normalizeBookTitle2(bookTitle);
  let bestMatch = null;
  for (const entry of titleCache) {
    const similarity = calculateSimilarity(normalizedBookTitle, entry.normalizedTitle);
    if (similarity >= SIMILARITY_THRESHOLD) {
      if (!bestMatch || similarity > bestMatch.similarity) {
        bestMatch = { path: entry.filePath, similarity };
      }
    }
  }
  if (bestMatch) {
    console.debug(`Best match: "${bestMatch.path}" (${(bestMatch.similarity * 100).toFixed(1)}%)`);
    if (bestMatch.path !== preferredPath) {
      try {
        await app.vault.adapter.rename(bestMatch.path, preferredPath);
        return preferredPath;
      } catch (e) {
        return bestMatch.path;
      }
    }
    return bestMatch.path;
  }
  return preferredPath;
}
async function processBook(app, outputPath, bookData, settings, result, cache, prefetchedInfo = /* @__PURE__ */ new Map(), titleCache = []) {
  const originalTitle = bookData.book.title;
  const originalAuthor = bookData.book.author;
  const filename = generateFilename(bookData.book.title);
  const filePath = await findExistingFile(app, outputPath, filename, bookData.book.title, titleCache, bookData.previousTitle);
  let cacheModified = false;
  const cachedInfo = getCachedInfo(cache, originalTitle, originalAuthor);
  const hasAttemptedFetch = cachedInfo && (cachedInfo.publishedDate !== void 0 && cachedInfo.publisher !== void 0 && cachedInfo.pageCount !== void 0);
  const existingData = await getExistingBookData(app, filePath);
  const fileExists = existingData !== null;
  console.log(`[${bookData.book.title}] processBook: highlights=${bookData.highlights.length}, fileExists=${fileExists}, highlightsCount=${existingData == null ? void 0 : existingData.highlightsCount}`);
  if (bookData.highlights.length === 0) {
    if (!fileExists) {
      if (!settings.trackBooksWithoutHighlights) {
        console.log(`[${bookData.book.title}] SKIP: no file, no highlights, tracking off`);
        result.booksSkipped++;
        return false;
      }
      console.log(`[${bookData.book.title}] FALL-THROUGH: no file, tracking on \u2014 will create`);
    } else if (settings.trackBooksWithoutHighlights) {
      if (existingData.highlightsCount === 0) {
        console.log(`[${bookData.book.title}] SKIP: file exists, 0 highlights, tracking on`);
        result.booksSkipped++;
        return false;
      }
      console.log(`[${bookData.book.title}] FALL-THROUGH: file exists but highlightsCount=${existingData.highlightsCount}`);
    } else if (hasUserNotes(existingData.fullContent)) {
      if (existingData.highlightsCount === 0) {
        result.booksSkipped++;
        return false;
      }
    } else {
      const file = app.vault.getAbstractFileByPath(filePath);
      if (file) {
        await app.vault.trash(file, false);
        result.booksDeleted++;
      }
      return false;
    }
  }
  if (fileExists) {
    const currentHash = computeHighlightsHash(bookData.highlights);
    const highlightsUnchanged = existingData.highlightsHash ? existingData.highlightsHash === currentHash : existingData.highlightsCount === bookData.highlights.length;
    const progressUnchanged = existingData.progress === bookData.progress;
    const newLastRead = bookData.lastReadTimestamp !== null ? new Date(bookData.lastReadTimestamp).toISOString().split("T")[0] : null;
    const lastReadUnchanged = existingData.lastRead === newLastRead;
    console.debug(`[${bookData.book.title}] Existing hash: ${existingData.highlightsHash || "none"} | New hash: ${currentHash}`);
    console.debug(`[${bookData.book.title}] Unchanged: highlights=${highlightsUnchanged}, progress=${progressUnchanged}, lastRead=${lastReadUnchanged}, hasAttemptedFetch=${hasAttemptedFetch}`);
    if (highlightsUnchanged && progressUnchanged && lastReadUnchanged && hasAttemptedFetch) {
      result.booksSkipped++;
      return false;
    }
  }
  const shouldFetchMetadata = true;
  if (shouldFetchMetadata) {
    const coverFilename = `${filename}.jpg`;
    const coversFolder = (0, import_obsidian7.normalizePath)(`${outputPath}/moonsync-covers`);
    const coverPath = (0, import_obsidian7.normalizePath)(`${coversFolder}/${coverFilename}`);
    let coverExists = await app.vault.adapter.exists(coverPath);
    if (bookData.book.coverFile) {
      const localCoverData = await getLocalCover(settings.syncPath, bookData.book.coverFile);
      if (localCoverData) {
        if (!await app.vault.adapter.exists(coversFolder)) {
          await app.vault.createFolder(coversFolder);
        }
        await app.vault.adapter.writeBinary(coverPath, localCoverData);
        bookData.coverPath = `moonsync-covers/${coverFilename}`;
        coverExists = true;
      }
    }
    if (cachedInfo) {
      if (cachedInfo.description && !bookData.fetchedDescription) {
        bookData.fetchedDescription = cachedInfo.description;
      }
      if (!bookData.book.author && cachedInfo.author) {
        bookData.book.author = cachedInfo.author;
      }
      if (cachedInfo.publishedDate && !bookData.publishedDate) {
        bookData.publishedDate = cachedInfo.publishedDate;
      }
      if (cachedInfo.publisher && !bookData.publisher) {
        bookData.publisher = cachedInfo.publisher;
      }
      if (cachedInfo.pageCount !== null && bookData.pageCount === null) {
        bookData.pageCount = cachedInfo.pageCount;
      }
      if (cachedInfo.genres && !bookData.genres) {
        bookData.genres = cachedInfo.genres;
      }
      if (cachedInfo.series && !bookData.series) {
        bookData.series = cachedInfo.series;
      }
      if (cachedInfo.language && !bookData.language) {
        bookData.language = cachedInfo.language;
      }
    }
    const prefetchKey = `${bookData.book.title}|${bookData.book.author}`;
    const bookInfo = prefetchedInfo.get(prefetchKey);
    if (bookInfo) {
      if (bookInfo.coverUrl && !coverExists) {
        if (!await app.vault.adapter.exists(coversFolder)) {
          await app.vault.createFolder(coversFolder);
        }
        const imageData = await downloadCover(bookInfo.coverUrl);
        if (imageData) {
          await app.vault.adapter.writeBinary(coverPath, imageData);
          bookData.coverPath = `moonsync-covers/${coverFilename}`;
        }
      }
      if (bookInfo.description && !bookData.fetchedDescription) {
        bookData.fetchedDescription = bookInfo.description;
      }
      if (!bookData.book.author && bookInfo.author) {
        bookData.book.author = bookInfo.author;
      }
      if (bookInfo.publishedDate && !bookData.publishedDate) {
        bookData.publishedDate = bookInfo.publishedDate;
      }
      if (bookInfo.publisher && !bookData.publisher) {
        bookData.publisher = bookInfo.publisher;
      }
      if (bookInfo.pageCount !== null && bookData.pageCount === null) {
        bookData.pageCount = bookInfo.pageCount;
      }
      if (bookInfo.genres && !bookData.genres) {
        bookData.genres = bookInfo.genres;
      }
      if (bookInfo.series && !bookData.series) {
        bookData.series = bookInfo.series;
      }
      if (bookInfo.language && !bookData.language) {
        bookData.language = bookInfo.language;
      }
      setCachedInfo(cache, originalTitle, originalAuthor, {
        title: originalTitle,
        description: bookInfo.description,
        author: bookInfo.author,
        publishedDate: bookInfo.publishedDate,
        publisher: bookInfo.publisher,
        pageCount: bookInfo.pageCount,
        genres: bookInfo.genres,
        series: bookInfo.series,
        language: bookInfo.language
      });
      cacheModified = true;
    }
    if (!cachedInfo && !bookInfo) {
      setCachedInfo(cache, originalTitle, originalAuthor, {
        title: originalTitle,
        description: bookData.book.description || null,
        author: bookData.book.author || null,
        publishedDate: bookData.publishedDate,
        publisher: bookData.publisher,
        pageCount: bookData.pageCount,
        genres: bookData.genres,
        series: bookData.series,
        language: bookData.language
      });
      cacheModified = true;
    }
    if (coverExists) {
      bookData.coverPath = `moonsync-covers/${coverFilename}`;
    }
  }
  let markdown;
  if (fileExists && existingData.isManualNote) {
    markdown = mergeManualNoteWithMoonReader(existingData.fullContent, bookData, settings);
  } else if (fileExists) {
    markdown = mergeExistingNoteWithHighlights(existingData.fullContent, bookData, settings);
  } else {
    markdown = generateBookNote(bookData, settings);
  }
  if (fileExists) {
    await app.vault.adapter.write(filePath, markdown);
    result.booksUpdated++;
  } else {
    await app.vault.create(filePath, markdown);
    result.booksCreated++;
  }
  return cacheModified;
}
async function processCustomBook(app, outputPath, scannedBook, settings, result, cache) {
  let cacheModified = false;
  try {
    const content = await app.vault.adapter.read(scannedBook.filePath);
    if (/^custom_metadata:\s*true/m.test(content)) {
      return false;
    }
  } catch (e) {
  }
  const cachedInfo = getCachedInfo(cache, scannedBook.title, scannedBook.author || "");
  if (cachedInfo && cachedInfo.publishedDate !== void 0 && cachedInfo.publisher !== void 0 && cachedInfo.pageCount !== void 0) {
    return false;
  }
  const author = scannedBook.author || "Unknown";
  const bookInfo = await fetchBookInfo(scannedBook.title, author);
  if (bookInfo.coverUrl || bookInfo.description || bookInfo.publishedDate || bookInfo.publisher || bookInfo.pageCount !== null || bookInfo.genres || bookInfo.series || bookInfo.language) {
    const content = await app.vault.adapter.read(scannedBook.filePath);
    const updatedContent = updateCustomBookFrontmatter(content, bookInfo, settings);
    await app.vault.adapter.write(scannedBook.filePath, updatedContent);
    setCachedInfo(cache, scannedBook.title, scannedBook.author, {
      title: bookInfo.title,
      // Canonical title from Google Books/Open Library
      description: bookInfo.description,
      author: bookInfo.author,
      publishedDate: bookInfo.publishedDate,
      publisher: bookInfo.publisher,
      pageCount: bookInfo.pageCount,
      genres: bookInfo.genres,
      series: bookInfo.series,
      language: bookInfo.language
    });
    cacheModified = true;
    result.booksUpdated++;
    if (bookInfo.coverUrl) {
      const coverFilename = `${generateFilename(scannedBook.title)}.jpg`;
      const coversFolder = (0, import_obsidian7.normalizePath)(`${outputPath}/moonsync-covers`);
      const coverPath = (0, import_obsidian7.normalizePath)(`${coversFolder}/${coverFilename}`);
      if (!await app.vault.adapter.exists(coverPath)) {
        if (!await app.vault.adapter.exists(coversFolder)) {
          await app.vault.createFolder(coversFolder);
        }
        const imageData = await downloadCover(bookInfo.coverUrl);
        if (imageData) {
          await app.vault.adapter.writeBinary(coverPath, imageData);
        }
      }
    }
  }
  return cacheModified;
}
function updateCustomBookFrontmatter(content, bookInfo, settings) {
  var _a, _b;
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) {
    return content;
  }
  const frontmatter = frontmatterMatch[1];
  const contentAfterFrontmatter = content.slice(frontmatterMatch[0].length);
  const lines = [];
  lines.push("---");
  const frontmatterLines = frontmatter.split("\n");
  let skipNextLine = false;
  for (const line of frontmatterLines) {
    if (skipNextLine && line.trim().startsWith("-")) {
      continue;
    }
    skipNextLine = false;
    if (line.startsWith("published_date:") || line.startsWith("publisher:") || line.startsWith("page_count:") || line.startsWith("genres:") || line.startsWith("series:") || line.startsWith("language:") || line.startsWith("cover:")) {
      if (line.startsWith("genres:")) {
        skipNextLine = true;
      }
      continue;
    }
    lines.push(line);
  }
  if (bookInfo.publishedDate) {
    lines.push(`published_date: "${escapeYaml2(bookInfo.publishedDate)}"`);
  }
  if (bookInfo.publisher) {
    lines.push(`publisher: "${escapeYaml2(bookInfo.publisher)}"`);
  }
  if (bookInfo.pageCount !== null) {
    lines.push(`page_count: ${bookInfo.pageCount}`);
  }
  if (bookInfo.genres && bookInfo.genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of bookInfo.genres) {
      lines.push(`  - "${escapeYaml2(genre)}"`);
    }
  }
  if (bookInfo.series) {
    lines.push(`series: "${escapeYaml2(bookInfo.series)}"`);
  }
  if (bookInfo.language) {
    lines.push(`language: "${bookInfo.language}"`);
  }
  const coverFilename = generateFilename(((_b = (_a = frontmatterLines.find((l) => l.startsWith("title:"))) == null ? void 0 : _a.split(":")[1]) == null ? void 0 : _b.trim().replace(/"/g, "")) || "");
  if (coverFilename) {
    lines.push(`cover: "moonsync-covers/${coverFilename}.jpg"`);
  }
  lines.push("---");
  return lines.join("\n") + contentAfterFrontmatter;
}
function escapeYaml2(str) {
  return str.replace(/"/g, '\\"').replace(/\n/g, " ");
}
async function updateIndexNote(app, outputPath, moonReaderBooks, settings) {
  const indexPath = (0, import_obsidian7.normalizePath)(`${outputPath}/${settings.indexNoteTitle}.md`);
  const scannedBooks = await scanAllBookNotes(app, outputPath);
  const indexFilename = `${settings.indexNoteTitle}.md`;
  const filteredScanned = scannedBooks.filter(
    (b) => !b.filePath.endsWith(indexFilename)
  );
  const allBooks = mergeBookLists(moonReaderBooks, filteredScanned);
  const markdown = generateIndexNote(allBooks, settings);
  if (await app.vault.adapter.exists(indexPath)) {
    await app.vault.adapter.write(indexPath, markdown);
  } else {
    await app.vault.create(indexPath, markdown);
  }
}
async function refreshIndexNote(app, settings) {
  if (!settings.showIndex) {
    new import_obsidian7.Notice("MoonSync: Index generation is disabled in settings");
    return;
  }
  const outputPath = (0, import_obsidian7.normalizePath)(settings.outputFolder);
  if (!await app.vault.adapter.exists(outputPath)) {
    new import_obsidian7.Notice("MoonSync: Output folder does not exist");
    return;
  }
  try {
    let moonReaderBooks = [];
    if (settings.syncPath) {
      try {
        moonReaderBooks = await parseAnnotationFiles(settings.syncPath, settings.trackBooksWithoutHighlights);
      } catch (e) {
      }
    }
    const coversFolder = (0, import_obsidian7.normalizePath)(`${outputPath}/moonsync-covers`);
    for (const bookData of moonReaderBooks) {
      if (!bookData.coverPath) {
        const coverFilename = `${generateFilename(bookData.book.title)}.jpg`;
        const coverPath = (0, import_obsidian7.normalizePath)(`${coversFolder}/${coverFilename}`);
        if (await app.vault.adapter.exists(coverPath)) {
          bookData.coverPath = `moonsync-covers/${coverFilename}`;
        }
      }
    }
    await updateIndexNote(app, outputPath, moonReaderBooks, settings);
    new import_obsidian7.Notice("MoonSync: Index refreshed");
  } catch (error) {
    console.error("MoonSync: Failed to refresh index", error);
    new import_obsidian7.Notice("MoonSync: Failed to refresh index");
  }
}
async function updateBaseFile(app, outputPath, settings) {
  const baseFilePath = (0, import_obsidian7.normalizePath)(`${outputPath}/${settings.baseFileName}.base`);
  const content = generateBaseFile(settings);
  if (await app.vault.adapter.exists(baseFilePath)) {
    await app.vault.adapter.write(baseFilePath, content);
  } else {
    await app.vault.create(baseFilePath, content);
  }
}
async function refreshBaseFile(app, settings) {
  if (!settings.generateBaseFile) {
    new import_obsidian7.Notice("MoonSync: Base file generation is disabled in settings");
    return;
  }
  const outputPath = (0, import_obsidian7.normalizePath)(settings.outputFolder);
  if (!await app.vault.adapter.exists(outputPath)) {
    new import_obsidian7.Notice("MoonSync: Output folder does not exist");
    return;
  }
  try {
    await updateBaseFile(app, outputPath, settings);
    new import_obsidian7.Notice("MoonSync: Base file refreshed");
  } catch (error) {
    console.error("MoonSync: Failed to refresh base file", error);
    new import_obsidian7.Notice("MoonSync: Failed to refresh base file");
  }
}
function showSyncResults(app, result, settings) {
  const hasFailedBooks = result.failedBooks && result.failedBooks.length > 0;
  if (result.success) {
    if (result.booksProcessed === 0 && !hasFailedBooks) {
      new import_obsidian7.Notice("MoonSync: No books with highlights to sync");
    } else if (result.isFirstSync || hasFailedBooks) {
      new SyncSummaryModal(app, result, settings).open();
    } else {
      const totalProcessed = result.booksCreated + result.booksUpdated + result.booksDeleted;
      const totalBooks = totalProcessed + result.booksSkipped + result.manualBooksAdded;
      if (totalProcessed === 0) {
        new import_obsidian7.Notice("MoonSync: All books up to date");
      } else {
        const parts = [];
        if (result.booksCreated + result.booksUpdated > 0) {
          parts.push(`Updated ${result.booksCreated + result.booksUpdated}`);
        }
        if (result.booksDeleted > 0) {
          parts.push(`Removed ${result.booksDeleted}`);
        }
        if (result.hardcoverUpdated && result.hardcoverUpdated > 0) {
          parts.push(`Hardcover: ${result.hardcoverUpdated} synced`);
        }
        new import_obsidian7.Notice(`MoonSync: ${parts.join(", ")} of ${totalBooks} books`);
      }
    }
  } else {
    new import_obsidian7.Notice(`MoonSync: Sync failed - ${result.errors[0]}`);
  }
  for (const error of result.errors) {
    console.error("MoonSync:", error);
  }
}

// src/parser/manual-export.ts
function parseManualExport(content) {
  const lines = content.split("\n");
  if (lines.length === 0) {
    return null;
  }
  const headerMatch = lines[0].match(/^(.+?)\s+-\s+(.+?)\s+\(Highlight:\s+\d+;\s+Note:\s+\d+\)$/);
  if (!headerMatch) {
    return null;
  }
  const title = headerMatch[1].trim();
  const author = headerMatch[2].trim();
  const highlights = [];
  let currentChapter = 0;
  let chapterName = "";
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line || line.startsWith("\u2500\u2500\u2500")) {
      continue;
    }
    if (line.startsWith("\u25C6")) {
      chapterName = line.substring(1).trim();
      const chapterMatch = chapterName.match(/Chapter\s+(\d+)/i);
      if (chapterMatch) {
        currentChapter = parseInt(chapterMatch[1]);
      } else {
        currentChapter++;
      }
      continue;
    }
    if (line.startsWith("\u25AA")) {
      let highlightText = line.substring(1).trim();
      let noteText = "";
      const noteMatch = highlightText.match(/^(.*?)\s+\((.+)\)$/);
      if (noteMatch) {
        highlightText = noteMatch[1].trim();
        noteText = noteMatch[2].trim();
      }
      highlights.push({
        originalText: highlightText,
        note: noteText,
        chapter: currentChapter,
        highlightColor: -256,
        // Yellow (default)
        timestamp: Date.now(),
        pagePos: 0,
        rangeStart: "",
        rangeEnd: ""
      });
    }
  }
  return {
    title,
    author,
    highlights
  };
}

// main.ts
init_hardcover();
var import_path7 = require("path");
var import_fs2 = require("fs");
var MoonSyncPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.ribbonIconEl = null;
    this.fileWatcher = null;
    this.watchDebounceTimer = null;
    this.isSyncing = false;
  }
  async onload() {
    console.log("MoonSync: BUILD 2026-02-23-A loaded");
    await this.loadSettings();
    this.addSettingTab(new MoonSyncSettingTab(this.app, this));
    this.updateRibbonIcon();
    this.updateContentVisibility();
    this.addCommand({
      id: "sync-now",
      name: "Sync now",
      callback: () => {
        void this.runSync();
      }
    });
    this.addCommand({
      id: "create-book-note",
      name: "Create book note",
      callback: () => this.openCreateBookModal()
    });
    this.addCommand({
      id: "import-note",
      name: "Import note",
      callback: () => {
        void this.importManualExport();
      }
    });
    this.addCommand({
      id: "refetch-cover",
      name: "Fetch book cover",
      callback: () => {
        void this.refetchBookCover();
      }
    });
    this.addCommand({
      id: "fetch-metadata",
      name: "Fetch book metadata",
      callback: () => {
        void this.fetchBookMetadata();
      }
    });
    this.addCommand({
      id: "update-hardcover",
      name: "Update Hardcover link",
      checkCallback: (checking) => {
        if (!this.settings.hardcoverEnabled || !this.settings.hardcoverToken)
          return false;
        if (!checking) {
          void this.updateHardcoverLink();
        }
        return true;
      }
    });
    if (this.settings.syncOnStartup) {
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => {
          void this.runSync();
        }, 2e3);
      });
    }
    if (this.settings.watchForChanges) {
      this.startFileWatcher();
    }
  }
  onunload() {
    this.stopFileWatcher();
    document.body.classList.remove(
      "moonsync-hide-covers",
      "moonsync-hide-reading-progress",
      "moonsync-hide-description",
      "moonsync-hide-highlight-colors"
    );
  }
  updateRibbonIcon() {
    if (this.ribbonIconEl) {
      this.ribbonIconEl.remove();
      this.ribbonIconEl = null;
    }
    if (this.settings.showRibbonIcon) {
      this.ribbonIconEl = this.addRibbonIcon(
        "book-open",
        "MoonSync: Sync now",
        () => {
          void this.runSync();
        }
      );
    }
  }
  updateContentVisibility() {
    document.body.classList.toggle("moonsync-hide-covers", !this.settings.showCovers);
    document.body.classList.toggle("moonsync-hide-reading-progress", !this.settings.showReadingProgress);
    document.body.classList.toggle("moonsync-hide-description", !this.settings.showDescription);
    document.body.classList.toggle("moonsync-hide-highlight-colors", !this.settings.showHighlightColors);
  }
  async runSync() {
    if (!this.settings.syncPath) {
      new import_obsidian8.Notice("MoonSync: Please configure the sync path in settings");
      return;
    }
    if (this.isSyncing) {
      console.log("MoonSync: Sync already in progress, skipping");
      return;
    }
    this.isSyncing = true;
    try {
      const wasmPath = this.getWasmPath();
      const result = await syncFromMoonReader(
        this.app,
        this.settings,
        wasmPath
      );
      showSyncResults(this.app, result, this.settings);
    } catch (error) {
      console.error("MoonSync sync error:", error);
      new import_obsidian8.Notice(`MoonSync: Sync failed - ${error}`);
    } finally {
      this.isSyncing = false;
    }
  }
  startFileWatcher() {
    this.stopFileWatcher();
    if (!this.settings.syncPath)
      return;
    const cachePath = (0, import_path7.join)(this.settings.syncPath, ".Moon+", "Cache");
    try {
      this.fileWatcher = (0, import_fs2.watch)(cachePath, { persistent: false }, (_event, filename) => {
        if (!filename)
          return;
        const name = filename.toString();
        if (!name.endsWith(".po") && !name.endsWith(".an"))
          return;
        if (this.watchDebounceTimer)
          clearTimeout(this.watchDebounceTimer);
        this.watchDebounceTimer = setTimeout(() => {
          console.log("MoonSync: File change detected, syncing...");
          void this.runSync();
        }, 3e3);
      });
      this.fileWatcher.on("error", (err) => {
        console.error("MoonSync: File watcher error", err);
        this.stopFileWatcher();
      });
      console.log("MoonSync: Watching for changes in", cachePath);
    } catch (err) {
      console.error("MoonSync: Failed to start file watcher", err);
    }
  }
  stopFileWatcher() {
    if (this.watchDebounceTimer) {
      clearTimeout(this.watchDebounceTimer);
      this.watchDebounceTimer = null;
    }
    if (this.fileWatcher) {
      this.fileWatcher.close();
      this.fileWatcher = null;
      console.log("MoonSync: File watcher stopped");
    }
  }
  /**
   * Get the path to the sql-wasm.wasm file bundled with the plugin
   */
  getWasmPath() {
    const pluginDir = this.app.vault.adapter.getBasePath();
    const pluginPath = this.manifest.dir;
    if (pluginPath) {
      return (0, import_path7.join)(pluginDir, pluginPath, "sql-wasm.wasm");
    }
    throw new Error("Could not determine plugin directory");
  }
  async loadSettings() {
    const data = await this.loadData();
    if (data && data.dropboxPath && !data.syncPath) {
      data.syncPath = data.dropboxPath;
      delete data.dropboxPath;
    }
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Open the modal to create a new book note
   */
  openCreateBookModal() {
    new CreateBookModal(
      this.app,
      this.settings,
      (bookInfo) => {
        void this.createBookNote(bookInfo);
      }
    ).open();
  }
  /**
   * Create a new book note from selected book info
   */
  async createBookNote(bookInfo) {
    var _a, _b, _c, _d, _e, _f, _g;
    const title = bookInfo.title || "Untitled";
    const progressNotice = new import_obsidian8.Notice("MoonSync: Creating book note...", 0);
    try {
      const outputPath = (0, import_obsidian8.normalizePath)(this.settings.outputFolder);
      const filename = generateFilename(title);
      const filePath = (0, import_obsidian8.normalizePath)(`${outputPath}/${filename}.md`);
      if (await this.app.vault.adapter.exists(filePath)) {
        progressNotice.hide();
        new import_obsidian8.Notice(`MoonSync: A note for "${title}" already exists`);
        return;
      }
      if (!await this.app.vault.adapter.exists(outputPath)) {
        await this.app.vault.createFolder(outputPath);
      }
      let coverPath = null;
      if (bookInfo.coverUrl) {
        try {
          const coversFolder = (0, import_obsidian8.normalizePath)(`${outputPath}/moonsync-covers`);
          if (!await this.app.vault.adapter.exists(coversFolder)) {
            await this.app.vault.createFolder(coversFolder);
          }
          const coverFilename = `${filename}.jpg`;
          const coverFilePath = (0, import_obsidian8.normalizePath)(`${coversFolder}/${coverFilename}`);
          const imageData = await downloadAndResizeCover(bookInfo.coverUrl);
          if (imageData) {
            await this.app.vault.adapter.writeBinary(coverFilePath, imageData);
            coverPath = `moonsync-covers/${coverFilename}`;
          }
        } catch (error) {
          console.debug(`MoonSync: Failed to download cover for "${title}"`, error);
        }
      }
      const content = generateBookTemplate(
        title,
        bookInfo.author || "",
        coverPath,
        this.settings.showDescription ? (_a = bookInfo.description) != null ? _a : null : null,
        (_b = bookInfo.publishedDate) != null ? _b : null,
        (_c = bookInfo.publisher) != null ? _c : null,
        (_d = bookInfo.pageCount) != null ? _d : null,
        (_e = bookInfo.genres) != null ? _e : null,
        (_f = bookInfo.series) != null ? _f : null,
        (_g = bookInfo.language) != null ? _g : null
      );
      await this.app.vault.create(filePath, content);
      progressNotice.hide();
      new import_obsidian8.Notice(`MoonSync: Created note for "${title}"`);
      if (this.settings.showIndex) {
        await refreshIndexNote(this.app, this.settings);
      }
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        await this.app.workspace.openLinkText(filePath, "", true);
      }
    } catch (error) {
      progressNotice.hide();
      console.error("MoonSync: Failed to create book note", error);
      new import_obsidian8.Notice(`MoonSync: Failed to create book note - ${error}`);
    }
  }
  async refreshIndex() {
    await refreshIndexNote(this.app, this.settings);
  }
  async refreshBase() {
    await refreshBaseFile(this.app, this.settings);
  }
  async deleteIndex() {
    const outputPath = (0, import_obsidian8.normalizePath)(this.settings.outputFolder);
    const indexPath = (0, import_obsidian8.normalizePath)(`${outputPath}/${this.settings.indexNoteTitle}.md`);
    if (await this.app.vault.adapter.exists(indexPath)) {
      const file = this.app.vault.getAbstractFileByPath(indexPath);
      if (file) {
        await this.app.vault.delete(file);
        new import_obsidian8.Notice("MoonSync: Index note deleted");
      }
    }
  }
  async deleteBase() {
    const outputPath = (0, import_obsidian8.normalizePath)(this.settings.outputFolder);
    const basePath = (0, import_obsidian8.normalizePath)(`${outputPath}/${this.settings.baseFileName}.base`);
    if (await this.app.vault.adapter.exists(basePath)) {
      const file = this.app.vault.getAbstractFileByPath(basePath);
      if (file) {
        await this.app.vault.delete(file);
        new import_obsidian8.Notice("MoonSync: Base file deleted");
      }
    }
  }
  async renameIndex(oldName, newName) {
    const outputPath = (0, import_obsidian8.normalizePath)(this.settings.outputFolder);
    const oldPath = (0, import_obsidian8.normalizePath)(`${outputPath}/${oldName}.md`);
    const newPath = (0, import_obsidian8.normalizePath)(`${outputPath}/${newName}.md`);
    const file = this.app.vault.getAbstractFileByPath(oldPath);
    if (file) {
      await this.app.fileManager.renameFile(file, newPath);
    }
  }
  async renameBase(oldName, newName) {
    const outputPath = (0, import_obsidian8.normalizePath)(this.settings.outputFolder);
    const oldPath = (0, import_obsidian8.normalizePath)(`${outputPath}/${oldName}.base`);
    const newPath = (0, import_obsidian8.normalizePath)(`${outputPath}/${newName}.base`);
    const file = this.app.vault.getAbstractFileByPath(oldPath);
    if (file) {
      await this.app.fileManager.renameFile(file, newPath);
    }
  }
  /**
   * Import a Moon Reader manual export note
   */
  async importManualExport() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian8.Notice("MoonSync: No active file to import");
      return;
    }
    const progressNotice = new import_obsidian8.Notice("MoonSync: Importing note...", 0);
    try {
      const content = await this.app.vault.read(activeFile);
      const exportData = parseManualExport(content);
      if (!exportData) {
        progressNotice.hide();
        new import_obsidian8.Notice("MoonSync: File is not a valid Moon Reader export");
        return;
      }
      const outputPath = (0, import_obsidian8.normalizePath)(this.settings.outputFolder);
      const filename = generateFilename(exportData.title);
      const filePath = (0, import_obsidian8.normalizePath)(`${outputPath}/${filename}.md`);
      if (await this.app.vault.adapter.exists(filePath)) {
        progressNotice.hide();
        new import_obsidian8.Notice(`MoonSync: A note for "${exportData.title}" already exists`);
        return;
      }
      if (!await this.app.vault.adapter.exists(outputPath)) {
        await this.app.vault.createFolder(outputPath);
      }
      let coverPath = null;
      let description = null;
      let publishedDate = null;
      let publisher = null;
      let pageCount = null;
      let genres = null;
      let series = null;
      let language = null;
      try {
        const bookInfo = await fetchBookInfo(exportData.title, exportData.author);
        if (bookInfo.coverUrl) {
          const coversFolder = (0, import_obsidian8.normalizePath)(`${outputPath}/moonsync-covers`);
          if (!await this.app.vault.adapter.exists(coversFolder)) {
            await this.app.vault.createFolder(coversFolder);
          }
          const coverFilename = `${filename}.jpg`;
          const coverFilePath = (0, import_obsidian8.normalizePath)(`${coversFolder}/${coverFilename}`);
          const imageData = await downloadCover(bookInfo.coverUrl);
          if (imageData) {
            await this.app.vault.adapter.writeBinary(coverFilePath, imageData);
            coverPath = `moonsync-covers/${coverFilename}`;
          }
        }
        description = bookInfo.description;
        publishedDate = bookInfo.publishedDate;
        publisher = bookInfo.publisher;
        pageCount = bookInfo.pageCount;
        genres = bookInfo.genres;
        series = bookInfo.series;
        language = bookInfo.language;
      } catch (error) {
        console.debug(`MoonSync: Failed to fetch book info for "${exportData.title}"`, error);
      }
      const bookData = {
        book: {
          id: 0,
          title: exportData.title,
          author: exportData.author,
          filename: "",
          description: "",
          category: "",
          thumbFile: "",
          coverFile: "",
          addTime: "",
          favorite: ""
        },
        highlights: exportData.highlights,
        statistics: null,
        progress: null,
        currentChapter: null,
        lastReadTimestamp: null,
        coverPath,
        fetchedDescription: description,
        publishedDate,
        publisher,
        pageCount,
        genres,
        series,
        isbn10: null,
        isbn13: null,
        language
      };
      const noteContent = generateBookNote(bookData, this.settings);
      await this.app.vault.create(filePath, noteContent);
      progressNotice.hide();
      new import_obsidian8.Notice(`MoonSync: Imported "${exportData.title}" with ${exportData.highlights.length} highlights`);
      if (this.settings.showIndex) {
        await refreshIndexNote(this.app, this.settings);
      }
      if (this.settings.generateBaseFile) {
        await refreshBaseFile(this.app, this.settings);
      }
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        await this.app.workspace.openLinkText(filePath, "", true);
      }
    } catch (error) {
      progressNotice.hide();
      console.error("MoonSync: Failed to import note", error);
      new import_obsidian8.Notice(`MoonSync: Failed to import note - ${error}`);
    }
  }
  /**
   * Re-fetch book cover for the current note
   */
  async refetchBookCover() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian8.Notice("MoonSync: No active file");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      const parsed = parseFrontmatter(content);
      if (!parsed.title) {
        new import_obsidian8.Notice("MoonSync: No title found in frontmatter");
        return;
      }
      const title = parsed.title.replace(/\\"/g, '"');
      const author = parsed.author ? parsed.author.replace(/\\"/g, '"') : "";
      new SelectCoverModal(
        this.app,
        title,
        author,
        (coverUrl) => {
          void this.handleCoverSelected(coverUrl, title, content, activeFile);
        }
      ).open();
    } catch (error) {
      console.error("MoonSync: Failed to re-fetch cover", error);
      new import_obsidian8.Notice(`MoonSync: Failed to re-fetch cover - ${error}`);
    }
  }
  async handleCoverSelected(coverUrl, title, content, activeFile) {
    const progressNotice = new import_obsidian8.Notice("MoonSync: Downloading cover...", 0);
    try {
      const outputPath = (0, import_obsidian8.normalizePath)(this.settings.outputFolder);
      const coversFolder = (0, import_obsidian8.normalizePath)(`${outputPath}/moonsync-covers`);
      if (!await this.app.vault.adapter.exists(coversFolder)) {
        await this.app.vault.createFolder(coversFolder);
      }
      const filename = generateFilename(title);
      const coverFilename = `${filename}.jpg`;
      const coverFilePath = (0, import_obsidian8.normalizePath)(`${coversFolder}/${coverFilename}`);
      const imageData = await downloadAndResizeCover(coverUrl);
      if (!imageData) {
        progressNotice.hide();
        new import_obsidian8.Notice("MoonSync: Failed to download cover image");
        return;
      }
      const existingFile = this.app.vault.getAbstractFileByPath(coverFilePath);
      if (existingFile instanceof import_obsidian8.TFile) {
        await this.app.vault.delete(existingFile);
      }
      await this.app.vault.createBinary(coverFilePath, imageData);
      const coverPath = `moonsync-covers/${coverFilename}`;
      const updatedContent = this.updateNoteCover(content, coverPath);
      const contentWithoutEmbed = updatedContent.replace(/!\[\[moonsync-covers\/[^\]]+\]\]\n?/, "");
      await this.app.vault.modify(activeFile, contentWithoutEmbed);
      await new Promise((resolve) => setTimeout(resolve, 50));
      await this.app.vault.modify(activeFile, updatedContent);
      await refreshIndexNote(this.app, this.settings);
      progressNotice.hide();
      new import_obsidian8.Notice("MoonSync: Cover updated successfully");
    } catch (error) {
      progressNotice.hide();
      console.error("MoonSync: Failed to download cover", error);
      new import_obsidian8.Notice(`MoonSync: Failed to download cover - ${error}`);
    }
  }
  /**
   * Update the cover field in frontmatter and add/update cover embed in note body
   */
  updateNoteCover(content, coverPath) {
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      return content;
    }
    const frontmatter = frontmatterMatch[1];
    let contentAfterFrontmatter = content.slice(frontmatterMatch[0].length);
    const lines = [];
    lines.push("---");
    let coverUpdated = false;
    for (const line of frontmatter.split("\n")) {
      if (line.startsWith("cover:")) {
        lines.push(`cover: "${coverPath}"`);
        coverUpdated = true;
      } else {
        lines.push(line);
      }
    }
    if (!coverUpdated) {
      lines.push(`cover: "${coverPath}"`);
    }
    lines.push("---");
    const coverEmbed = `![[${coverPath}|200]]`;
    const coverEmbedPattern = /!\[\[moonsync-covers\/[^\]]+\|\d+\]\]/;
    if (coverEmbedPattern.test(contentAfterFrontmatter)) {
      contentAfterFrontmatter = contentAfterFrontmatter.replace(coverEmbedPattern, coverEmbed);
    } else {
      const authorPattern = /(\*\*Author:\*\*[^\n]*\n)/;
      const titlePattern = /(# [^\n]+\n)/;
      if (authorPattern.test(contentAfterFrontmatter)) {
        contentAfterFrontmatter = contentAfterFrontmatter.replace(
          authorPattern,
          `$1
${coverEmbed}
`
        );
      } else if (titlePattern.test(contentAfterFrontmatter)) {
        contentAfterFrontmatter = contentAfterFrontmatter.replace(
          titlePattern,
          `$1
${coverEmbed}
`
        );
      }
    }
    return lines.join("\n") + contentAfterFrontmatter;
  }
  /**
   * Fetch and replace all book metadata for the current note
   */
  async fetchBookMetadata() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian8.Notice("MoonSync: No active file");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      const parsed = parseFrontmatter(content);
      if (!parsed.title) {
        new import_obsidian8.Notice("MoonSync: No title found in frontmatter");
        return;
      }
      const title = parsed.title.replace(/\\"/g, '"');
      const author = parsed.author ? parsed.author.replace(/\\"/g, '"') : "";
      new SelectBookMetadataModal(
        this.app,
        title,
        author,
        (bookInfo) => {
          void this.handleMetadataSelected(bookInfo, title, content, activeFile);
        }
      ).open();
    } catch (error) {
      console.error("MoonSync: Failed to fetch metadata", error);
      new import_obsidian8.Notice(`MoonSync: Failed to fetch metadata - ${error}`);
    }
  }
  /**
   * Update the Hardcover link for the current note by providing a Hardcover URL
   */
  async updateHardcoverLink() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian8.Notice("MoonSync: No active file");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const parsed = parseFrontmatter(content);
    if (!parsed.title) {
      new import_obsidian8.Notice("MoonSync: No title found in frontmatter");
      return;
    }
    new UpdateHardcoverModal(this.app, (url) => {
      void this.handleHardcoverUrlSubmit(url, content, activeFile, parsed.progress);
    }).open();
  }
  async handleHardcoverUrlSubmit(url, content, activeFile, progress) {
    const slugMatch = url.match(/hardcover\.app\/books\/([^/?#]+)/);
    if (!slugMatch) {
      new import_obsidian8.Notice("MoonSync: Invalid Hardcover URL. Expected format: https://hardcover.app/books/...");
      return;
    }
    const slug = slugMatch[1];
    const progressNotice = new import_obsidian8.Notice("MoonSync: Looking up book on Hardcover...", 0);
    try {
      const book = await lookupBookBySlug(slug, this.settings.hardcoverToken);
      if (!book) {
        progressNotice.hide();
        new import_obsidian8.Notice("MoonSync: Book not found on Hardcover");
        return;
      }
      let updated = content;
      updated = updated.replace(/^hardcover_id: .*\n/m, "");
      updated = updated.replace(/^hardcover_progress: .*\n/m, "");
      updated = updated.replace(/^hardcover_url: .*\n/m, "");
      const fields = `hardcover_id: ${book.id}
hardcover_url: "https://hardcover.app/books/${book.slug}"`;
      updated = updated.replace(/\n---\n/, `
${fields}
---
`);
      await this.app.vault.modify(activeFile, updated);
      if (progress !== null && progress > 0) {
        progressNotice.setMessage("MoonSync: Syncing progress to Hardcover...");
        const statusId = progress >= 99 ? 3 : 2;
        await updateHardcoverBook(book.id, statusId, progress, book.pages, this.settings.hardcoverToken);
      }
      progressNotice.hide();
      new import_obsidian8.Notice(`MoonSync: Linked to "${book.title}" on Hardcover`);
    } catch (error) {
      progressNotice.hide();
      console.error("MoonSync: Failed to update Hardcover link", error);
      new import_obsidian8.Notice(`MoonSync: Failed to update Hardcover link - ${error}`);
    }
  }
  async handleMetadataSelected(bookInfo, title, content, activeFile) {
    var _a;
    const progressNotice = new import_obsidian8.Notice("MoonSync: Updating metadata...", 0);
    try {
      const fileDir = ((_a = activeFile.parent) == null ? void 0 : _a.path) || "";
      const coversFolder = (0, import_obsidian8.normalizePath)(`${fileDir}/moonsync-covers`);
      let coverPath = null;
      const newTitle = bookInfo.title || title;
      const newFilename = generateFilename(newTitle);
      const newFilePath = (0, import_obsidian8.normalizePath)(`${fileDir}/${newFilename}.md`);
      if (bookInfo.coverUrl) {
        if (!await this.app.vault.adapter.exists(coversFolder)) {
          await this.app.vault.createFolder(coversFolder);
        }
        const coverFilename = `${newFilename}.jpg`;
        const coverFilePath = (0, import_obsidian8.normalizePath)(`${coversFolder}/${coverFilename}`);
        const imageData = await downloadAndResizeCover(bookInfo.coverUrl);
        if (imageData) {
          const existingCover = this.app.vault.getAbstractFileByPath(coverFilePath);
          if (existingCover instanceof import_obsidian8.TFile) {
            await this.app.vault.delete(existingCover);
          }
          await this.app.vault.createBinary(coverFilePath, imageData);
          coverPath = `moonsync-covers/${coverFilename}`;
        }
      }
      const updatedContent = this.updateNoteMetadata(content, bookInfo, coverPath);
      const contentWithoutEmbed = updatedContent.replace(/!\[\[moonsync-covers\/[^\]]+\]\]\n?/, "");
      await this.app.vault.modify(activeFile, contentWithoutEmbed);
      await new Promise((resolve) => setTimeout(resolve, 50));
      await this.app.vault.modify(activeFile, updatedContent);
      if (activeFile.basename !== newFilename) {
        await this.app.fileManager.renameFile(activeFile, newFilePath);
      }
      await refreshIndexNote(this.app, this.settings);
      progressNotice.hide();
      new import_obsidian8.Notice("MoonSync: Metadata updated successfully");
    } catch (error) {
      progressNotice.hide();
      console.error("MoonSync: Failed to update metadata", error);
      new import_obsidian8.Notice(`MoonSync: Failed to update metadata - ${error}`);
    }
  }
  /**
   * Update all metadata fields in frontmatter and note body
   */
  updateNoteMetadata(content, bookInfo, coverPath) {
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      return content;
    }
    const frontmatter = frontmatterMatch[1];
    let contentAfterFrontmatter = content.slice(frontmatterMatch[0].length);
    const escapeYaml3 = (str) => str.replace(/"/g, '\\"').replace(/\n/g, " ");
    const fieldsToReplace = /* @__PURE__ */ new Set(["title", "author", "published_date", "publisher", "page_count", "genres", "series", "language", "cover", "rating", "ratings_count", "custom_metadata"]);
    const frontmatterLines = [];
    let skipNextLines = false;
    for (const line of frontmatter.split("\n")) {
      if (line.startsWith("  -")) {
        if (skipNextLines)
          continue;
        frontmatterLines.push(line);
        continue;
      }
      skipNextLines = false;
      const fieldMatch = line.match(/^(\w+):/);
      if (fieldMatch) {
        const field = fieldMatch[1];
        if (fieldsToReplace.has(field)) {
          if (field === "genres") {
            skipNextLines = true;
          }
          continue;
        }
      }
      frontmatterLines.push(line);
    }
    const lines = [];
    lines.push("---");
    for (const line of frontmatterLines) {
      if (line.trim()) {
        lines.push(line);
      }
    }
    if (bookInfo.title) {
      lines.push(`title: "${escapeYaml3(bookInfo.title)}"`);
    }
    if (bookInfo.author) {
      lines.push(`author: "${escapeYaml3(bookInfo.author)}"`);
    }
    if (bookInfo.publishedDate) {
      lines.push(`published_date: "${escapeYaml3(bookInfo.publishedDate)}"`);
    }
    if (bookInfo.publisher) {
      lines.push(`publisher: "${escapeYaml3(bookInfo.publisher)}"`);
    }
    if (bookInfo.pageCount !== null) {
      lines.push(`page_count: ${bookInfo.pageCount}`);
    }
    if (bookInfo.genres && bookInfo.genres.length > 0) {
      lines.push(`genres:`);
      for (const genre of bookInfo.genres) {
        lines.push(`  - "${escapeYaml3(genre)}"`);
      }
    }
    if (bookInfo.series) {
      lines.push(`series: "${escapeYaml3(bookInfo.series)}"`);
    }
    if (bookInfo.language) {
      lines.push(`language: "${bookInfo.language}"`);
    }
    if (coverPath) {
      lines.push(`cover: "${coverPath}"`);
    }
    lines.push(`custom_metadata: true`);
    lines.push("---");
    if (bookInfo.title) {
      contentAfterFrontmatter = contentAfterFrontmatter.replace(
        /^(# ).+$/m,
        `$1${bookInfo.title}`
      );
    }
    if (bookInfo.author) {
      if (/\*\*Author:\*\*/.test(contentAfterFrontmatter)) {
        contentAfterFrontmatter = contentAfterFrontmatter.replace(
          /\*\*Author:\*\*[^\n]*/,
          `**Author:** ${bookInfo.author}`
        );
      }
    }
    if (coverPath) {
      const coverEmbed = `![[${coverPath}|200]]`;
      const coverEmbedPattern = /!\[\[moonsync-covers\/[^\]]+\|\d+\]\]/;
      if (coverEmbedPattern.test(contentAfterFrontmatter)) {
        contentAfterFrontmatter = contentAfterFrontmatter.replace(coverEmbedPattern, coverEmbed);
      } else {
        const authorPattern = /(\*\*Author:\*\*[^\n]*\n)/;
        const titlePattern = /(# [^\n]+\n)/;
        if (authorPattern.test(contentAfterFrontmatter)) {
          contentAfterFrontmatter = contentAfterFrontmatter.replace(
            authorPattern,
            `$1
${coverEmbed}
`
          );
        } else if (titlePattern.test(contentAfterFrontmatter)) {
          contentAfterFrontmatter = contentAfterFrontmatter.replace(
            titlePattern,
            `$1
${coverEmbed}
`
          );
        }
      }
    }
    return lines.join("\n") + contentAfterFrontmatter;
  }
};
/*! Bundled license information:

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/
